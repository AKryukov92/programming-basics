<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8"/>
		<link href="styles.css" rel="stylesheet"></link>
	</head>
	<body>
	Цитата из книги "Совершенный код" с комментариями. Автор: С.Макконнел
	<p>Купить всю книгу можно на следующих сайтах:
	<ul>
		<li>ozon.ru <a href="http://www.ozon.ru/context/detail/id/138437220/" target="_blank">(открыть в новой вкладке)</a></li>
		<li>market.yandex.ru <a href="https://market.yandex.ru/product--makkonnell-s-sovershennyi-kod-master-klass/1545077" target="_blank">(открыть в новой вкладке)</a></li>
	</ul>
	</p>
	<h3>Часть IV. Глава 15.1 Операторы if</h3>
<p>В зависимости от выбранного языка программирования вы можете использовать несколько видов if-операторов. Простейшие из них — if или if-then. Оператор if-then-else немного сложнее, а наибольшую сложность представляют последовательности if-then-else-if.</p>
<h4>Простые операторы if-then</h4>
<p>Следуйте этим правилам при написании if-выражений.</p>
<p><b>Сначала напишите код номинального хода алгоритма, затем опишите исключительные случаи</b> Пишите код так, чтобы нормальный путь выполнения был очевиден. Убедитесь, что нестандартные обстоятельства не затмевают смысл основного алгоритма. Это важно как с точки зрения читабельности, так и с точки зрения производительности.</p>
<p><b>Убедитесь, что при сравнении на равенство ветвление корректно</b> Использование &gt; вместо &gt;= или &lt; вместо &lt;= — это аналог ошибки потери единицы при обращении к массиву или вычислении индекса цикла. Чтобы ее избежать, в операторе цикла следует рассматривать граничные точки, а в условных операторах — учитывать случаи равенства.</p>
<p><b>Размещайте нормальный вариант после if, а не после else</b> Пишите код так, чтобы нормальный вариант развития событий обрабатывался в первую очередь. Это совпадает с главным принципом размещения действий, являющихся результатом выбора, как можно ближе к точке этого выбора. Вот пример кода, который выполняет неоднократную проверку ошибок, беспорядочно разбросанную по тексту:</p>
<p>Пример кода, который беспорядочно обрабатывает многочисленные ошибки (Visual Basic)</p>
<p class="preformatted">OpenFile( inputFile, status )
If ( status = Status_Error ) Then
<span class="comment">'Ошибочная ситуация.</span>
    errorType = FileOpenError
Else
<span class="comment">'Нормальная ситуация.</span>
    ReadFile( inputFile, fileData, status )
    If ( status = Status_Success ) Then
<span class="comment">'Нормальная ситуация.</span>
        SummarizeFileData( fileData, summaryData, status )
        If ( status = Status_Error ) Then
<span class="comment">'Ошибочная ситуация.</span>
            errorType = ErrorType_DataSummaryError
        Else
<span class="comment">'Нормальная ситуация.</span>
            PrintSummary( summaryData )
            SaveSummaryData( summaryData, status )
            If ( status = Status_Error ) Then
<span class="comment">'Ошибочная ситуация.</span>
                errorType = ErrorType_SummarySaveError
            Else
<span class="comment">'Нормальная ситуация.</span>
                UpdateAllAccounts()
                EraseUndoFile()
                errorType = ErrorType_None
            End If
        End If
    Else
<span class="comment">'Ошибочная ситуация.</span>
        errorType = ErrorType_FileReadError
    End If
End If</p>
<p>Этот код сложен для понимания, так как в нем перемешаны нормальные и ошибочные ситуации. Тяжело проследить путь, проходимый в коде при нормальных обстоятельствах. Кроме того, так как ошибки иногда обрабатываются в блоке if, а не else, тяжело найти, в каких же ветвях if обрабатываются нормальные ситуации. В переписанном примере нормальный путь последовательно кодируется первым, а ошибочные ситуации — последними. Это упрощает поиск и чтение номинального варианта алгоритма.</p>
<p>Пример кода, который систематично обрабатывает большое количество ошибок (Visual Basic)</p>
<p class="preformatted">OpenFile( inputFile, status )
If ( status = Status_Success ) Then
<span class="comment">Нормальная ситуация.</span>
    ReadFile( inputFile, fileData, status )
    If ( status = Status_Success ) Then
<span class="comment">Нормальная ситуация.</span>
        SummarizeFileData( fileData, summaryData, status )
        If ( status = Status_Success ) Then
<span class="comment">Нормальная ситуация.</span>
            PrintSummary( summaryData )
            SaveSummaryData( summaryData, status )
            If ( status = Status_Success ) Then
<span class="comment">Нормальная ситуация.</span>
                UpdateAllAccounts()
                EraseUndoFile()
                errorType = ErrorType_None
            Else
<span class="comment">Ошибочная ситуация.</span>
                errorType = ErrorType_SummarySaveError
            End If
        Else
<span class="comment">Ошибочная ситуация.</span>
            errorType = ErrorType_DataSummaryError
        End If
    Else
<span class="comment">Ошибочная ситуация.</span>
        errorType = ErrorType_FileReadError
    End If
Else
<span class="comment">Ошибочная ситуация.</span>
    errorType = ErrorType_FileOpenError
End If</p>
<p>Здесь можно проследить главное направление if-проверок, чтобы выяснить нормальный вариант событий. Этот фрагмент позволяет фокусировать чтение в основном направлении, а не преодолевать исключительные ситуации, поэтому этот код в целом читабельнее. Стек ошибочных условий, расположенный внизу вложения, — признак хорошо написанного кода обработки ошибок.</p>
<p>Этот пример иллюстрирует один систематический подход к обработке нормальных и ошибочных ситуаций. Есть и другие решения этой проблемы:</p>
<ul>
	<li>использование предохранительных конструкций,</li>
	<li>диспетчеризация полиморфных объектов,</li>
	<li>вынесение внутренних проверок в отдельные методы</li>
</ul>
<p>Они обсуждаются на протяжении всей книги. Полный список существующих подходов см. в разделе 19.4.</p>
<p><b>Размещайте осмысленные выражения после оператора if</b> Иногда можно встретить код, в котором блок if пуст:</p>
<p>Пример пустого блока if (Java)</p>
<p class="preformatted">if ( SomeTest )
 ;
else {
 // делаем что-то
 ...
}</p>
<p>Опытные программисты не станут писать такой код хотя бы затем, чтобы избежать лишней работы по вводу пустой строки и оператора else. Этот код выглядит глупо и может быть легко улучшен путем отрицания предиката в выражении if, перемещения кода из блока else в блок if и удаления блока else. Вот как будет выглядеть код после таких изменений:</p>
<p>Пример преобразования пустого блока if (Java)</p>
<p class="preformatted">if ( ! someTest ) {
 // делаем что-то
 ...
}</p>
<p><b>Рассмотрите вопрос использования блока else</b> Если вы считаете, что вам нужен простой оператор if, подумайте, может, вам на самом деле нужен вариант с if-then-else. Классический анализ General Motors показал, что в 50–80- случаев использования операторов if следовало применять и оператор else (Elshoff, 1976).</p>
<p>Одна из причин добавления блока else — даже пустого — в том, чтобы продемонстрировать, что вариант с else был учтен. Конечно, кодирование пустых выражений в else просто для того, чтобы показать, что этот вариант рассмотрен, может быть преувеличением, но хотя бы принимайте вариант с else во внимание. Если вы задаете if-проверку, не имеющую блока else, то, кроме очевидных случаев, пишите в комментариях объяснение, почему else отсутствует, скажем, так:</p>
<p>Пример полезного, прокомментированного блока elsе (Java)</p>
<p class="preformatted">
// Если цвет задан корректно.
if ( COLOR_MIN &lt;= color && color &lt;= COLOR_MAX ) {
 // Делаем что-то
 ...
}
else {
 // Иначе цвет задан некорректно.
 // Вывод на экран не выполняется – просто игнорируем команду.
}</p>
<p><b>Проверяйте корректность выражения else</b> При тестировании кода вы можете решить, что достаточно проверить основной блок if и все. Однако, если можно проверить вариант в else, не забудьте это сделать.</p>
<p><b>Проверяйте возможную перестановку блоков if и else</b> Частая ошибка при программировании выражений if-then состоит в размещении кода из блока if в блоке else, т. е. инвертировании логики выражения if. Проверяйте ваш код на наличие этой ошибки.</p>
<h4>Последовательности операторов if-then-else</h4>
<p>Если язык не поддерживает операторы case или поддерживает их только частично, вам часто придется писать последовательные проверки if-then-else. К примеру, код распределения символов по категориям, может выглядеть в виде такой цепочки:</p>
<p>Пример использования последовательности if-then-else для распределения символов по категориям (C++)</p>
<p class="preformatted">if ( inputCharacter &lt; SPACE ) {
    characterType = CharacterType_ControlCharacter;
}
else if (
    inputCharacter == ‘ ‘ ||
    inputCharacter == ‘,’ ||
    inputCharacter == ‘.’ ||
    inputCharacter == ‘!’ ||
    inputCharacter == ‘(‘ ||
    inputCharacter == ‘)’ ||
    inputCharacter == ‘:’ ||
    inputCharacter == ‘;’ ||
    inputCharacter == ‘?’ ||
    inputCharacter == ‘-’
    ) {
    characterType = CharacterType_Punctuation;
}
else if ( ‘0’ &lt;= inputCharacter && inputCharacter &lt;= ‘9’ ) {
    characterType = CharacterType_Digit;
}
else if (
    ( ‘a’ &lt;= inputCharacter && inputCharacter &lt;= ‘z’ ) ||
    ( ‘A’ &lt;= inputCharacter && inputCharacter &lt;= ‘Z’ )
    ) {
    characterType = CharacterType_Letter;
}</p>
<p>Учитывайте советы, приведенные далее, при написании последовательных if-then-else.</p>
<p><b>Упрощайте сложные проверки с помощью вызовов логических функций</b> Одна из причин, по которой код из предыдущего примера сложно читать, в том, что проверки категорий символов довольно сложны. Для улучшения читабельности вы можете заменить их вызовами функций, возвращающих логические значения. Вот как этот пример может выглядеть после замены условий логическими функциями:</p>
<p>Пример последовательности if-then-else, использующей вызовы логических функций (C++)</p>
<p class="preformatted">if ( IsControl( inputCharacter ) ) {
    characterType = CharacterType_ControlCharacter;
}
else if ( IsPunctuation( inputCharacter ) ) {
    characterType = CharacterType_Punctuation;
}
else if ( IsDigit( inputCharacter ) ) {
    characterType = CharacterType_Digit;
}
else if ( IsLetter( inputCharacter ) ) {
    characterType = CharacterType_Letter;
}</p>
<p><b>Размещайте наиболее вероятные варианты раньше остальных</b> Поместив в начало наиболее часто встречающиеся ситуации, вы минимизируете то количество кода, обрабатывающего исключительные случаи, которое придется прочитать при поиске обычных вариантов. Вы увеличите эффективность, потому что уменьшите число проверок, выполняемых кодом в большинстве случаев. В приведенном примере буквы обычно встречаются чаще, чем знаки пунктуации, но проверка этих знаков написана первой. Вот как исправить код, чтобы буквы проверялись в первую очередь:</p>
<p>Пример проверки прежде всего наиболее часто встречающихся вариантов (C++)</p>
<p class="preformatted"><span class="comment">Этот случай встречается чаще других, поэтому проверяем его первым.</span>
if ( IsLetter( inputCharacter ) ) {
    characterType = CharacterType_Letter;
}
else if ( IsPunctuation( inputCharacter ) ) {
    characterType = CharacterType_Punctuation;
}
else if ( IsDigit( inputCharacter ) ) {
    characterType = CharacterType_Digit;
}
<span class="comment">Этот случай наиболее редкий, поэтому проверяем его последним.</span>
else if ( IsControl( inputCharacter ) ) {
    characterType = CharacterType_ControlCharacter;
}</p>
<p><b>Убедитесь, что учтены все варианты</b> Закодируйте в последнем блоке else сообщение об ошибке или утверждение, чтобы отловить ситуации, которые вы не планировали. Это сообщение об ошибке предназначено скорее вам, а не пользователю, так что сформулируйте его соответственно. Вот как модифицировать пример классификации символов для выполнения проверки «других вариантов»:</p>
<p>Пример использования варианта по умолчанию для перехвата ошибок (C++)</p>
<p class="preformatted">if ( IsLetter( inputCharacter ) ) {
    characterType = CharacterType_Letter;
}
else if ( IsPunctuation( inputCharacter ) ) {
    characterType = CharacterType_Punctuation;
}
else if ( IsDigit( inputCharacter ) ) {
    characterType = CharacterType_Digit;
}
else if ( IsControl( inputCharacter ) ) {
    characterType = CharacterType_ControlCharacter;
}
else {
    DisplayInternalError( "Unexpected type of character detected." );
}</p>
<p><b>Замените последовательности if-then-else другими конструкциями, которые поддерживает ваш язык программирования</b> Некоторые языки, скажем, Microsoft Visual Basic и Ada, предоставляют операторы case, поддерживающие строки, перечисления и логические функции. Используйте их — они проще в написании и чтении, чем цепочки if-then-else. Код классификации типов символов, написанный на Visual Basic с помощью оператора case, может выглядеть так:</p>
<p>Пример использования оператора case вместо последовательности if-then-else (Visual Basic)</p>
<p class="preformatted">Select Case inputCharacter
    Case "a" To "z"
        characterType = CharacterType_Letter
    Case " ", ",", ".", "!", "(", ")", ":", ";", "?", "-"
        characterType = CharacterType_Punctuation
    Case "0" To "9"
        characterType = CharacterType_Digit
    Case FIRST_CONTROL_CHARACTER To LAST_CONTROL_CHARACTER
        characterType = CharacterType_Control
    Case Else
        DisplayInternalError( "Unexpected type of character detected." )
End Select</p>
	</body>
</html>