<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8"/>
		<link href="styles.css" rel="stylesheet"></link>
	</head>
	<body>
	Цитата из книги "Совершенный код" с комментариями. Автор: С.Макконнел
	<p>Купить всю книгу можно на следующих сайтах:
	<ul>
		<li>ozon.ru <a href="http://www.ozon.ru/context/detail/id/138437220/" target="_blank">(открыть в новой вкладке)</a></li>
		<li>market.yandex.ru <a href="https://market.yandex.ru/product--makkonnell-s-sovershennyi-kod-master-klass/1545077" target="_blank">(открыть в новой вкладке)</a></li>
	</ul>
	</p>
	<h3>Часть III. Глава 12.2  Целые числа</h3>
<p>Учитывайте следующие рекомендации при применении целых чисел.</p>
<p><b>Проверяйте целочисленность операций деления</b> Когда используются целые числа, выражение 7/10 не равно 0,7. Оно обычно равно 0 или минус бесконечности, или ближайшему целому, или… ну, вы понимаете. Результат зависит от выбранного языка. Это же относится и к промежуточным результатам. В реальном мире 10 * (7/10) = (10*7) / 10 = 7. Но не в мире целочисленной арифметики. 10 * (7/10) равно 0, потому что целочисленное деление (7/10) равно 0. Простейший способ
исправить положение — преобразовать его так, чтобы операции деления выполнялись последними: (10*7) / 10.</p>
<p><b>Проверяйте переполнение целых чисел</b> При выполнении умножения или сложения необходимо принимать во внимание наибольшие возможные значения целых чисел. Для целого числа без знака это обычно 2<sup>32</sup> –1, а иногда и 2<sup>16</sup> –1, или 65 535. Проблема возникает, когда вы умножаете два числа, в результате чего получается число большее, чем максимально возможное целое. Скажем, если вы умножаете 250 * 300, правильным ответом будет 75 000. Но если максимальное целое — 65 535,
то, возможно, из-за переполнения вы получите 9464 (75 000 – 65 536 = 9464). Вот интервалы значений для часто встречающихся целых типов (табл. 12-1):</p>
<p>Табл. 12-1. Интервалы значений некоторых целых типов</p>
<table>
	<tr>
		<th>Целый тип</th>         <th>Интервал</th>
	</tr>
	<tr>
		<td>8-битный со знаком</td><td>От –128 до 127</td>
	</tr>
	<tr>
		<td>8-битный без знака</td> <td>От 0 до 255</td>
	</tr>
	<tr>
		<td>16-битный со знаком</td> <td>От –32 768 до 32 767</td>
	</tr>
	<tr>
		<td>16-битный без знака</td> <td>От 0 до 65 535</td>
	</tr>
	<tr>
		<td>32-битный со знаком</td> <td>От –2 147 483,648 до 2 147 483 647</td>
	</tr>
	<tr>
		<td>32-битный без знака</td> <td>От 0 до 4 294 967 295</td>
	</tr>
	<tr>
		<td>64-битный со знаком</td> <td>От –9 223 372 036 854 775 808 до 9 223 372 036 854 775 807</td>
	</tr>
	<tr>
		<td>64-битный без знака</td> <td>От 0 до 18 446 744 073 709 551 615</td>
	</tr>
</table>
<p>Простейший способ предотвращения целочисленного переполнения — просмотр каждого члена арифметического выражения с целью представить наибольшее возможное значение, которое он может принимать. Так, если в целочисленном выражении m = j * k, наибольшим значением для j будет 200, а для k — 25, то максимальным значением для m будет 200 * 25 = 5 000. Для 32-разрядных машин это вполне допустимо, так как максимальным целым является 2 147 483 647. С другой стороны, если максимально возможное значение для j — это 200 000, а для k — 100 000, то значение m может достигать 200 000 * 100 000 = 20 000 000 000. Это уже неприемлемо, так как 20 000 000 000 больше, чем 2 147 483 647. В этом случае для размещения наибольшего возможного значения m вам придется использовать 64-битные целые или числа с плавающей запятой.</p>
<p>Кроме того, учитывайте будущее развитие программы. Если m никогда не будет больше 5 000 — отлично. Но если ожидается, что m будет постоянно расти на протяжении нескольких лет, примите это во внимание.</p>
<p><b>Проверяйте на переполнение промежуточные результаты</b> Число, получаемое в конце вычислений, — не единственное, о котором следует беспокоиться. Представьте, что у вас есть такой код:</p>
<p>Пример переполнения промежуточных результатов (Java)</p>
<p class="preformatted">int termA = 1000000;
int termB = 1000000;
int product = termA * termB / 1000000;
System.out.println( “( “ + termA + “ * “ + termB + “ ) / 1000000 = “ + product );
</p>
<p>Вы можете подумать, что значение Product вычисляется как (100 000*100 000) / 100 000 и поэтому равно 100 000. Но программе приходится вычислять промежуточное значение 100 000*100 000 до того, как будет выполнено деление на 100 000, а это значит, что нужно хранить такое большое число, как 1 000 000 000 000. Угадайте, что получится? Вот результат:</p>
<p class="preformatted">( 1000000 * 1000000 ) / 1000000 = -727</p>
<p>Если значение целых чисел в вашей системе не превышает 2 147 483 647, промежуточный результат слишком велик для целого типа данных. В такой ситуации промежуточный результат, который должен быть равен 1 000 000 000 000, на самом деле равен 727 379 968, поэтому, когда вы делите его на 100 000, вы получаете -727 вместо 100 000.</p>
<p>Вы можете решить проблему переполнения промежуточных результатов так же, как и в случае целочисленного переполнения: изменив тип на длинное целое или число с плавающей запятой.</p>
	</body>
</html>