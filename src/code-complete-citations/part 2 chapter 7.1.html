<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8"/>
		<link href="styles.css" rel="stylesheet"></link>
	</head>
	<body>
	Цитата из книги "Совершенный код" с комментариями. Автор: С.Макконнел
	<p>Купить всю книгу можно на следующих сайтах:
	<ul>
		<li>ozon.ru <a href="http://www.ozon.ru/context/detail/id/138437220/" target="_blank">(открыть в новой вкладке)</a></li>
		<li>market.yandex.ru <a href="https://market.yandex.ru/product--makkonnell-s-sovershennyi-kod-master-klass/1545077" target="_blank">(открыть в новой вкладке)</a></li>
	</ul>
	</p>
	<h3>Часть II. Глава 7.1 "Разумные причины создания методов"</h3>
<p>Ниже я привел список причин создания метода. Они несколько перекрываются и не исключают одна другую.</p>
<p><b>Снижение сложности</b> Самая важная причина создания метода — снижение сложности программы. Создайте метод для сокрытия информации, чтобы о ней можно было не думать. Конечно, при написании метода думать о ней придется, но после этого вы сможете забыть о деталях и использовать метод, не зная о его внутренней работе. Другие причины создания методов — минимизация объема кода, облегчение сопровождения программы и снижение числа ошибок — также хороши, но без абстрагирующей силы методов сложные программы было бы невозможно охватить умом.</p>
<p>Одним из признаков того, что метод следует разделить, является глубокая вложенность внутренних циклов или условных операторов. Упростите такой метод, выделив вложенную часть в отдельный метод.</p>
<p><b>Формирование понятной промежуточной абстракции</b> Выделение фрагмента кода в удачно названный метод — один из лучших способов документирования его цели. Вместо того, чтобы работать с фрагментами вида:</p>
<p class="preformatted">if ( node <> NULL ) then
    while ( node.next <> NULL ) do
        node = node.next
        leafName = node.name
    end while
else
    leafName = ””
end if</p>
<p>вы можете иметь дело с чем-нибудь вроде:</p>
<p class="preformatted">leafName = GetLeafName( node )</p>
<p>Новый метод так прост, что для документирования достаточно присвоить ему удачное имя. В сравнении с первоначальными восемью строками кода имя метода формирует абстракцию более высокого уровня, что облегчает чтение и понимание кода, а также снижает его сложность.</p>
<p><b>Предотвращение дублирования кода</b> Несомненно, самая популярная причина создания метода — желание избежать дублирования кода. Действительно, включение похожего кода в два метода указывает на ошибку декомпозиции. Уберите повторяющийся фрагмент из обоих методов, поместите его общую версию в базовый класс и создайте два специализированных метода в подклассах. Вы также можете выделить общий код в отдельный метод и вызвать его из двух первоначальных методов. В результате программа станет компактнее. Изменять ее станет проще, так как в случае чего вам нужно будет изменить только один метод. Код станет надежнее, потому что для его проверки нужно будет проанализировать только один фрагмент. Изменения будут реже приводить к ошибкам, поскольку вы не сможете по невнимательности внести в идентичные фрагменты программы чуть различающиеся изменения.</p>
<p><b>Поддержка наследования</b> Переопределить небольшой грамотно организованный метод легче, чем длинный и плохо спроектированный. Кроме того, стремление к простоте переопределяемых методов уменьшает вероятность ошибок при реализации подклассов.</p>
<p><b>Сокрытие очередности действий</b> Скрывать очередность обработки событий — разумная идея. Например, если программа обычно сначала вызывает метод, запрашивающий информацию у пользователя, а после этого — метод, читающий вспомогательные данные из файла, никакой из этих двух методов не должен зависеть от порядка их выполнения. В качестве другого примера можно привести две строки кода, первая из которых читает верхний элемент стека, а вторая уменьшает переменную stackTop. Вместо того чтобы распространять такой код по всей системе, скройте предположение о необходимом порядке выполнения двух операций, поместив две эти строки в метод PopStack().</p>
<p><b>Сокрытие операций над указателями</b> Операции над указателями не отличаются удобочитаемостью и часто являются источником ошибок. Изолировав такие операции в методах, вы сможете сосредоточиться на их сути, а не на механизме манипуляций над указателями. Кроме того, выполнение операций над указателями в одном месте облегчает проверку правильности кода. Если же вы найдете более эффективный тип данных, чем указатели, изменения затронут лишь несколько методов.</p>
<p><b>Улучшение портируемости</b> Использование методов изолирует непортируемый код, явно определяя фрагменты, которые придется изменить при портировании приложения. В число непортируемых аспектов входят нестандартные возможности языка, зависимости от оборудования и операционной системы и т. д.</p>
<p><b>Упрощение сложных булевых проверок</b> Понимание сложных булевых проверок редко требуется для понимания пути выполнения программы. Поместив такую проверку в метод, вы сможете упростить код, потому что (1) детали проверки будут скрыты и (2) описательное имя метода позволит лучше охарактеризовать суть проверки.</p>
<p>Создание отдельного метода для проверки подчеркивает ее значимость. Это мотивирует программистов сделать детали проверки внутри метода более удобочитаемыми. В результате и основной путь выполнения кода, и сама проверка становятся более понятными. Упрощение булевых проверок является примером снижения сложности, которого мы уже не раз касались.</p>
<p><b>Повышение быстродействия</b> Методы позволяют выполнять оптимизацию кода в одном месте, а не в нескольких. Они облегчают профилирование кода, направленное на определение неэффективных фрагментов. Если код централизован в методе, его оптимизация повысит быстродействие всех фрагментов, в которых этот метод вызывается как непосредственно, так и косвенно, а реализация метода на более эффективном языке или с применением улучшенного алгоритма окажется более выгодной.</p>
<p><b>Для уменьшения объема других методов?</b> Нет. При наличии стольких разумных причин создания методов эта не нужна. На самом деле для решения некоторых задач лучше использовать один крупный метод (об оптимальном размере метода см. раздел 7.4).</p>
<h4>Операция кажется слишком простой, чтобы создавать для нее метод</h4>
<p>Один из главных ментальных барьеров, препятствующих созданию эффективных методов, — нежелание создавать простой метод для простой цели. Создание метода для двух или трех строк кода может показаться пальбой из пушки по воробьям, но опыт свидетельствует о том, что небольшие методы могут быть чрезвычайно полезны.</p>
<p>Небольшие методы обеспечивают несколько преимуществ, и одно из них — облегчение чтения кода. Так, однажды я обнаружил следующую строку примерно в десятке мест программы:</p>
<p>Пример вычисления (псевдокод)</p>
<p class="preformatted">points = deviceUnits * ( POINTS_PER_INCH / DeviceUnitsPerInch() )</p>
<p>Наверняка это не самая сложная строка кода в вашей жизни. Большинство людей в итоге поняло бы, что она преобразует некоторую величину, выраженную в аппаратных единицах, в соответствующее число точек, а кроме того, что каждая из десятка строк делает одно и то же. Однако эти фрагменты можно было сделать еще более ясными, поэтому я создал метод с выразительным именем, выполняющий преобразование в одном месте:</p>
<p>Пример вычисления, преобразованного в функцию (псевдокод)</p>
<p class="preformatted">Function DeviceUnitsToPoints ( deviceUnits Integer ): Integer
    DeviceUnitsToPoints = deviceUnits *
        ( POINTS_PER_INCH / DeviceUnitsPerInch() )
End Function</p>
<p>В результате все десять первоначальных фрагментов стали выглядеть примерно так:</p>
<p>Пример вызова функции (псевдокод)</p>
<p class="preformatted">points = DeviceUnitsToPoints( deviceUnits )</p>
<p>Эта строка более понятна и даже кажется очевидной.</p>
<p>Данный пример позволяет назвать еще одну причину создания отдельных методов для простых операций: дело в том, что простые операции имеют свойство усложняться с течением времени. После того как я написал метод DeviceUnitsPerlnch(), оказалось, что в определенных условиях при активности определенных устройств он возвращает 0. Для предотвращения деления на 0 мне пришлось написать еще три строки кода:</p>
<p>Пример кода, расширяющегося при сопровождении программы (псевдокод)</p>
<p class="preformatted">Function DeviceUnitsToPoints( deviceUnits: Integer ) Integer;
    if ( DeviceUnitsPerInch() <> 0 )
        DeviceUnitsToPoints = deviceUnits *
            ( POINTS_PER_INCH / DeviceUnitsPerInch() )
    else
        DeviceUnitsToPoints = 0
    end if
End Function</p>
<p>Если бы в коде по-прежнему использовалась первоначальная строка, мне пришлось бы повторить проверку десять раз, добавив в общей сложности 30 строк кода.Создание простого метода позволило уменьшить это число до 3.</p>
<h4>Резюме причин создания методов</h4>
<p>Вот список разумных причин создания методов:</p>
<ul>
<li>снижение сложности;</li>
<li>формирование понятной промежуточной абстракции;</li>
<li>предотвращение дублирования кода;</li>
<li>поддержка наследования;</li>
<li>сокрытие очередности действий;</li>
<li>сокрытие операций над указателями;</li>
<li>улучшение портируемости;</li>
<li>упрощение сложных булевых проверок;</li>
<li>повышение быстродействия.</li>
</ul>
<p>Кроме того, разумными причинами создания методов можно считать многие из причин создания классов:</p>
<ul>
<li>изоляция сложности;</li>
<li>сокрытие деталей реализации;</li>
<li>ограничение влияния изменений;</li>
<li>сокрытие глобальных данных;</li>
<li>создание центральных точек управления;</li>
<li>облегчение повторного использования кода;</li>
<li>выполнение специфического вида рефакторинга.</li>
</ul>
	</body>
</html>