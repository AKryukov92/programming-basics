<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8"/>
		<link href="styles.css" rel="stylesheet"></link>
	</head>
	<body>
	Цитата из книги "Совершенный код" с комментариями. Автор: С.Макконнел
	<p>Купить всю книгу можно на следующих сайтах:
	<ul>
		<li>ozon.ru <a href="http://www.ozon.ru/context/detail/id/138437220/" target="_blank">(открыть в новой вкладке)</a></li>
		<li>market.yandex.ru <a href="https://market.yandex.ru/product--makkonnell-s-sovershennyi-kod-master-klass/1545077" target="_blank">(открыть в новой вкладке)</a></li>
	</ul>
	</p>
<h3>9.2  Псевдокод для профи</h3>
<p>Псевдокодом называют неформальную нотацию на естественном языке, описывающую работу алгоритма, метода, класса или программы. «Процесс программирования с псевдокодом» относится к конкретной методике применения псевдокода для эффективного создания кода методов.</p>
<p>Поскольку псевдокод напоминает естественный язык, разумно предположить, что любая перефразировка ваших мыслей, выполненная на нем, будет иметь одинаковый эффект. На практике же вы обнаружите, что некоторые стили псевдокода предпочтительней других.</p>
<ul>
<li>Применяйте формулировки, в точности описывающие отдельные действия.</li>
<li>Избегайте синтаксических элементов языков программирования. Псевдокод позволяет проектировать на несколько более высоком уровне, чем код. Применяя конструкции языка программирования, вы мыслите на более низком уровне и теряете преимущества проектирования на высоком уровне, загружая себя ненужными синтаксическими ограничениями.</li>
<li>Пишите псевдокод на уровне намерений. Описывайте назначение подхода, а не то, как этот подход нужно реализовать на выбранном языке программирования.</li>
<li>Пишите псевдокод на достаточно низком уровне, так чтобы код из него генерировался практически автоматически. Если псевдокод написан на слишком высоком уровне, могут возникнуть проблемы кодирования. Детализируйте псевдокод до тех пор, пока вам не покажется, что проще было бы написать код.</li>
</ul>
<p>Написав псевдокод, вы окружаете его кодом, а псевдокод превращаете в комментарии программы. Если вы руководствуетесь перечисленными правилами создания псевдокода, комментарии в вашей программе будут полными и ясными.</p>
<p>Вот пример псевдокода, в котором нарушены практически все перечисленные
правила:</p>
<p>Пример плохого псевдокода</p>
<p class="preformatted">увеличить номер ресурса на 1
выделить структуру dlg посредством malloc
если malloc() возвращает NULL вернуть 1
вызвать OSrsrc_init для инициализации ресурса
*hRsrcPtr = номер ресурса
вернуть 0</p>
<p>Какие намерения описывает этот блок псевдокода? Трудно сказать, поскольку написан он плохо. Этот так называемый псевдокод плох потому, что включает конкретику целевого языка программирования: *hRsrcPtr (описание указателя, специфичное для языка C) и malloc() (функция C). Этот блок псевдокода показывает, как будет написан код, а не описывает его назначение. Он вдается в излишние подробности: вернет ли процедура 1 или 0. Если посмотреть, можно ли превратить этот псевдокод в нормальные комментарии, видно, что толку от него мало.</p>
<p>А вот описание тех же действий на гораздо лучшем псевдокоде:</p>
<p>Пример хорошего псевдокода</p>
<p class="preformatted">Отслеживать текущее число используемых ресурсов
Если другой ресурс доступен
 Выделить структуру для диалогового окна
 Если структура для диалогового окна может быть выделена
 Учесть, что используется еще один ресурс
 Инициализировать ресурс
 Хранить номер ресурса в вызывающей программе
 Конец «если»
Конец «если»
Вернуть true, если новый ресурс был создан; иначе вернуть false</p>
<p>Этот псевдокод лучше предыдущего, так как полностью написан на естественном языке и не использует специфических конструкций целевого языка программирования. В первом примере псевдокод подлежал реализации только на C. Во втором же псевдокод не накладывает ограничений на используемый язык. Второй блок также написан на уровне описания намерений. О чем речь во втором блоке? Наверное, это легче понять, чем в первом блоке.</p>
<p>Хотя второй блок написан на понятном естественном языке, он достаточно точен и подробен, чтобы быть основой программы. Когда предложения этого псевдокода будут преобразованы в комментарии, они станут хорошим пояснением назначения кода.</p>
<p>Вот выгоды, которые вы получите, применяя такой стиль псевдокода.</p>
<ul>
<li>Псевдокод упрощает пересмотр конструкции — вам не потребуется вникать в
исходный код.</li>
<li>Псевдокод поддерживает идею итеративного усовершенствования. Вы начинаете с высокоуровневой конструкции, уточняете ее до псевдокода, который в свою очередь преобразуете в исходный код. Такое последовательное усовершенствование, осуществляемое шаг за шагом, позволяет проверять свои проектные решения по мере перехода на более низкие уровни. В результате вы обнаруживаете высокоуровневые ошибки на самом верхнем уровне, среднеуровневые — на среднем, а низкоуровневые — на самом нижнем, прежде чем они создадут проблемы.</li>
<li>Псевдокод упрощает внесение изменений. Что проще: исправить линию на чертеже или снести стену и сдвинуть ее на метр в сторону? В программировании эффект не столь драматичен в плане физических усилий, но идея та же: несколько строк псевдокода легче исправить, чем страницу кода. Одна из основ успеха проекта — отловить ошибку на «наименее значимой стадии», когда для ее исправления требуется минимум усилий. Поиск ошибки на стадии псевдокода требует гораздо меньше затрат, чем после полного кодирования, тестирования и отладки, так что есть экономический стимул обнаружить ошибку как можно раньше.</li>
<li>Псевдокод упрощает комментирование программ. В типичной ситуации вы сначала пишете код, а затем добавляете комментарии. В ППП предложения псевдокода становятся комментариями, так что на самом деле их проще оставить, чем удалить.</li>
<li>Псевдокод сопровождать проще, чем другие виды проектной документации. При других подходах проектная документация отделена от кода, и внесение в нее изменений порождает несоответствие. В ППП предложения псевдокода становятся комментариями программы. Внося изменения в комментарии, вы, таким образом, поддерживаете в корректном состоянии проектную документацию.</li>
</ul>
<p>Псевдокод как инструмент проектирования трудно переоценить. Исследования показали, что программисты предпочитают псевдокод за его возможности упрощать создание программных конструкций, помощь в определении некорректных проектных решений, простоту документирования и внесения изменений (Ramsey, Atwood, and Van Doren, 1983). Псевдокод — не единственный инструмент детального проектирования, но наряду с ППП — полезная вещь в инструментарии программиста. Попробуйте его в деле. В следующем разделе я расскажу как.</p>
<h3>9.3 Конструирование методов с использованием ППП</h3>
<p class="comment">Советы в этой главе полезны, даже если сейчас термин "метод" не знаком.</p>
<p>В этом разделе описаны этапы конструирования методов, а именно:</p>
<ul>
<li>проектирование метода;</li>
<li>кодирование метода;</li>
<li>проверка кода;</li>
<li>наведение глянца;</li>
<li>повторение предыдущих шагов при необходимости.</li>
</ul>
<h4>Проектирование метода</h4>
<p>Определив состав методов класса, приступайте к их проектированию. Допустим, вы хотите написать метод вывода сообщения об ошибке, основанного на коде ошибки, и назвали этот метод ReportErrorMessage(). Вот неформальная
спецификация ReportErrorMessage():</p>
<p class="preformatted">ReportErrorMessage() принимает в качестве входного параметра код ошибки и
выводит сообщение об ошибке, соответствующее этому коду. Он отвечает за
обработку недопустимых кодов. Если программа интерактивная, ReportErrorMessage()
выводит сообщение пользователю. Если она работает в режиме командной строки,
ReportErrorMessage() заносит сообщение в файл. После вывода сообщения
ReportErrorMessage() возвращает значение статуса, указывающее,
успешно ли он завершился.</p>
Этот метод используется в качестве примера во всей главе, а в оставшейся части этого раздела описывается его проектирование.</p>
<p><b>Проверка предварительных условий</b> Прежде чем что-либо делать с самой процедурой, убедитесь, что функции метода четко определены и соответствуют общим проектным решениям.</p>
<p><b>Определите задачу, решаемую методом</b> Сформулируйте задачу, решаемую методом настолько детально, чтобы можно было переходить созданию метода. Если проект высокого уровня достаточно подробен, эта работа уже сделана. Проект верхнего уровня должен содержать по крайней мере:</p>
<ul>
<li>информацию, скрываемую методом;</li>
<li>входные данные;</li>
<li>выходные данные;</li>
<li>предусловия, которые гарантированно должны соблюдаться до вызова метода (входные значения находятся в заданном диапазоне, потоки инициализированы, файлы открыты или закрыты, буферы заполнены или очищены и т. д.);</li>
<li>постусловия, которые гарантированно должны соблюдаться, прежде чем метод вернет управление вызывающей программе (выходные значения находятся в заданном диапазоне, потоки инициализированы, файлы открыты или закрыты, буферы заполнены или очищены и т. д.).</li>
</ul>
<p>Вот как это выглядит для метода ReportErrorMessage():</p>
<ul>
<li>метод скрывает текст сообщения и текущий метод обработки (интерактивный
или командной строки);</li>
<li>выполнение каких-либо предусловий не требуется;</li>
<li>входными данными является код ошибки;</li>
<li>выходные данные двух видов: сообщение об ошибке и статус, возвращаемый ReportErrorMessage() вызывающей программе;</li>
<li>возвращаемый статус должен принимать одно из двух значений: Success или
Failure.</li>
</ul>
<p><b>Название метода</b> Вопрос именования метода кажется тривиальным, но хорошее название — признак высокого стиля программирования и дело это непростое. Вообще метод должен иметь понятное, недвусмысленное имя. Затруднения в выборе имени метода могут свидетельствовать о том, что его назначение не совсем понятно. Неясное, невыразительное имя метода сродни предвыборным обещаниям политиков. Вроде бы о чем-то оно говорит, но если задуматься — непонятно о чем. Если можно дать методу более ясное имя, сделайте это. Если невыразительное имя — результат неясных проектных решений, вернитесь к ним и измените их.</p>
<p>В нашем примере ReportErrorMessage() — вполне недвусмысленное имя. Хорошее имя.</p>
<p><b>Решите, как тестировать метод</b> В процессе написания метода думайте о том, как вы будете его тестировать. Это принесет пользу вам при блочном тестировании и тестировщикам, проводящим независимое тестирование.</p>
<p>В нашем примере входные данные просты, так что можно планировать тестирование ReportErrorMessage() со всеми допустимыми кодами ошибок и различными неверными кодами.</p>
<p><b>Исследуйте функциональность, предоставляемую стандартными библиотеками</b> Основная возможность улучшить качество и производительность своего кода — повторно использовать имеющийся хороший код. Если метод кажется вам слишком сложным и у вас возникают проблемы с его проектированием, спросите себя, не реализована ли часть его функциональности в библиотеках языка, платформы или средства разработки, которые вы применяете. Нет ли нужного кода в стандартных библиотеках вашей компании? Множество алгоритмов уже реализовано, протестировано, обсуждено в профессиональной литературе, пересмотрено и усовершенствовано. Не тратьте время на реализацию готового алгоритма, по которому написана кандидатская диссертация.</p>
<p><b>Продумайте обработку ошибок</b> Подумайте обо всем плохом, что может случиться с вашим методом. Подумайте о плохих входных данных, недопустимых значениях, возвращаемых другими методами, и т. д.</p>
<p>Методы могут обрабатывать ошибки разными способами, и вам нужно четко определиться с одним из них. Если стратегию обработки ошибок определяет архитектура программы, вы можете просто следовать этой стратегии. В других случаях вам следует решить, какой подход будет оптимален в данном конкретном случае.</p>
<p><b>Думайте об эффективности</b> В зависимости от ситуации вы можете подходить к эффективности одним из двух способов. В первом случае — в подавляющем большинстве систем — эффективность некритична. При этом убедитесь, что интерфейс метода достаточно абстрагирован, а код читабелен и при необходимости вы сможете его легко усовершенствовать. При хорошей инкапсуляции вы сможете заменить медленные, ресурсоемкие конструкции языка высокого уровня более эффективным алгоритмом или реализацией на быстром, компактном языке низкого уровня, не затронув при этом другие методы.</p>
<p>Во втором случае — в незначительном числе систем — производительность критична. Проблемы производительности могут быть связаны с недостатком соединений с базой данных, ограниченной памятью, малым количеством доступных дескрипторов и другими ресурсами. Архитектура должна указывать, сколько ресурсов каждому методу (или классу) может быть предоставлено и как быстро он должен выполнять свои операции.</p>
<p>Как правило, не стоит тратить много усилий на оптимизацию отдельных методов. Эффективность в основном определяется конструкцией высокого уровня. Обычно микрооптимизация выполняется, только когда закончена вся программа и выясняется, что высокоуровневая конструкция исчерпала свои возможности обеспечить нужную производительность. Не теряйте время на вылизывание отдельных методов, пока не выяснится, что это необходимо.</p>
<p><b>Исследуйте алгоритмы и типы данных</b> Если доступные стандартные библиотеки не предоставляют нужной функциональности, имеет смысл исследовать литературу с описанием алгоритмов. Если вы нашли подходящий готовый алгоритм, корректно адаптируйте его к применяемому вами языку программирования.</p>
<p><b>Пишите псевдокод</b> У вас не будет сложностей, если вы прошли все предыдущие этапы, основное назначение которых в том, чтобы у вас сложилось четкое понимание того, что нужно писать.</p>
<p>Закончив предыдущие этапы, можно приступать к написанию высокоуровневого псевдокода. Запускайте редактор кода или интегрированную среду разработки и пишите псевдокод, который станет основой исходного текста программы.</p>
<p>Начните с основных моментов, а затем детализируйте их. Самая главная часть метода — заголовок#комментарий, описывающий действия метода, так что начните с краткой формулировки назначения метода. Написание этой формулировки поможет вам прояснить ваше понимание метода. Если вы испытываете затруднения при написании этого обобщенного комментария, вам, видимо, следует лучше разобраться с ролью этого метода. Вот пример краткого заголовка-комментария метода:</p>
<p class="preformatted">//Пример заголовка метода
//Этот метод выводит сообщение об ошибке на основании кода ошибки, получаемого от
//вызывающей программы. Способ вывода сообщения зависит от режима работы, который он
//определяет сам. Он возвращает значение, указывающее на успешное завершение или сбой</p>
<p>Написав общий комментарий, добавьте высокоуровневый псевдокод:</p>
<p>Пример псевдокода метода</p>
<p class="preformatted">Этот метод выводит сообщение об ошибке на основании кода ошибки, получаемого от
вызывающей программы. Способ вывода сообщения зависит от режима работы, который он
определяет сам. Он возвращает значение, указывающее на успешное завершение или сбой.

Установить статус по умолчанию в “сбой”.
Найти сообщение, соответствующее коду ошибки.

Если код ошибки корректен
 Если работа в интерактивном режиме, вывести сообщение
 и указать успешный статус.
 Если работа в режиме командной строки, запротоколировать
 сообщение об ошибке и указать успешный статус.
Если код ошибки некорректен, информировать пользователя
об обнаружении внутренней ошибки.
Вернуть статус</p>
<p>Еще раз: этот псевдокод достаточно высокого уровня, он не содержит конструкций языка программирования, а объясняет последовательность действий на естественном языке.</p>
<p>Продумайте применение данных К структуре данных можно подходить с разных позиций. В нашем примере данные простые, и манипуляция над ними не является существенной частью метода. В противном случае важно продумать основные фрагменты данных до построения логики метода. Когда вы будете строить логику метода, структуры основных типов данных окажутся весьма
полезны.</p>
<p><b>Проверьте псевдокод</b> Написав псевдокод и спроектировав данные, уделите минутку просмотру написанного. Задумайтесь, как бы вы объяснили это кому-то другому.</p>
<p>Попросите кого-нибудь прочитать написанное или выслушать ваше объяснение. Вам может показаться глупым просить коллегу посмотреть на какие-то 11 строк псевдокода, но результат вас удивит. Псевдокод более явно обозначит ваши ошибочные намерения, чем код на языке программирования. К тому же люди охотней просматривают несколько строк псевдокода своих коллег, чем 35 строк программы на C++ или Java.</p>
<p>Убедитесь, что вы имеете четкое представление о том, что и как делает метод. Если вы не понимаете его концептуально, на уровне псевдокода, какой же тогда у вас шанс разобраться в нем на уровне языка программирования? Если его не понимаете вы, кто его поймет?</p>
<p><b>Опишите несколько идей псевдокодом и выберите лучшую (пройдите по циклу)</b> Прежде чем кодировать, реализуйте как можно больше своих идей в псевдокоде. Приступив к кодированию, вы эмоционально вовлекаетесь в этот процесс, и вам труднее отказаться от плохого проекта и начать заново.</p>
<p>Общая идея: раз за разом проходиться по псевдокоду, пока каждое его предложение не станет настолько простым, что под ним можно будет вставить строку программы, а псевдокод оставить в качестве документации. Часть псевдокода, написанного при первых проходах, может оказаться достаточно высокоуровневой и потребовать дальнейшей декомпозиции. Не забывайте это сделать. Если вам не понятно, как закодировать какой#то фрагмент, продолжайте работать с псевдокодом, пока это не прояснится. Продолжайте уточнение и декомпозицию, пока это не будет выглядеть как напрасная трата времени по сравнению с написанием настоящего кода.</p>
<h4>Кодирование метода</h4>
<p>Спроектировав метод, приступайте к его конструированию.</p>
<p><b>Объявление метода</b> Напишите интерфейсный оператор метода: объявление функции на C++, метода на Java, функции или подпрограммы на Microsoft Visual Basic и т. д. в зависимости от применяемого языка. Превратите существующий заголовочный комментарий в комментарий соответствующего языка и оставьте его над уже написанным псевдокодом. Вот интерфейсный оператор и заголовок нашего примера на C++:</p>
<p><b>Пример интерфейса метода и заголовка, добавленных к псевдокоду (C++)</b></p>
<p>Это заголовочный комментарий, превращенный в комментарий C++.</p>
<p class="preformatted">/* Этот метод выводит сообщение об ошибке на основании кода ошибки, получаемого от
вызывающей программы. Способ вывода сообщения зависит от режима работы, который он
определяет сам. Он возвращает значение, указывающее на успешное завершение или сбой.
*/</p>
<p>Это интерфейсный оператор.</p>
<p class="preformatted">Status ReportErrorMessage(
 ErrorCode errorToReport
 )
Установить статус по умолчанию в “сбой”.
Найти сообщение, соответствующее коду ошибки.
Если код ошибки корректен
 Если работа в интерактивном режиме, вывести сообщение
 и указать успешный статус.
 Если работа в режиме командной строки, запротоколировать
 сообщение об ошибке и указать успешный статус.
Если код ошибки некорректен, информировать пользователя
об обнаружении внутренней ошибки.
Вернуть статус.</p>
<p><b>Изменение псевдокода на высокоуровневые комментарии</b> Добавим первый и последний оператор: { и } на C++ и превратим псевдокод в комментарии:
<p><b>Пример первого и последнего оператора вокруг псевдокода (C++)</b></p>
<p class="preformatted">/* Этот метод выводит сообщение об ошибке на основании кода ошибки, получаемого от
вызывающей программы. Способ вывода сообщения зависит от режима работы, который он
определяет сам. Он возвращает значение, указывающее на успешное завершение или сбой.
*/
Status ReportErrorMessage(
 ErrorCode errorToReport
 ) {</p>
<p>С этого места предложения псевдокода заменены на комментарии C++.</p>
<p class="preformatted"> // Установить статус по умолчанию в “сбой”.
 // Найти сообщение, соответствующее коду ошибки.
 // Если код ошибки корректен
  // Если работа в интерактивном режиме, вывести сообщение
  // и указать успешный статус.
  // Если работа в режиме командной строки, запротоколировать
  // сообщение об ошибке и указать успешный статус.
 // Если код ошибки некорректен, информировать пользователя
 // об обнаружении внутренней ошибки.
 // Вернуть статус.
}</p>
<p>Теперь роль метода очевидна. Проектные работы закончены, и вы без всякого кода видите, как работает метод.</p>
<p><b>Напишите код под каждым комментарием</b> Добавьте код под каждой строкой комментария. Это напоминает написание курсовой работы: сначала вы пишете план, а затем, под каждым его пунктом, — абзац текста. Каждый комментарий соответствует блоку или абзацу кода. Длина абзаца кода, как и длина абзаца литературного текста, зависит от высказываемой мысли, а его качество — от понимания автором сути.</p>
<p><b>Пример добавления кода к комментариям (C++)</b></p>
<p class="preformatted">/* Этот метод выводит сообщение об ошибке на основании кода ошибки, получаемого от
вызывающей программы. Способ вывода сообщения зависит от режима работы, который он
определяет сам. Он возвращает значение, указывающее на успешное завершение или сбой.
*/
Status ReportErrorMessage(
 ErrorCode errorToReport
 ) {</p>
<p>Добавленный код.</p>
<p class="preformatted"> // Установить статус по умолчанию в “сбой”.
 Status errorMessageStatus = Status_Failure;</p>
<p>Новая переменная errorMessage.</p>
<p class="preformatted"> // Найти сообщение, соответствующее коду ошибки.
 Message errorMessage = LookupErrorMessage( errorToReport );</p>
<p class="preformatted">// Если код ошибки корректен.
  // Если работа в интерактивном режиме, вывести сообщение
  // и указать успешный статус.
  // Если работа в режиме командной строки, запротоколировать
  // сообщение об ошибке и указать успешный статус.
 // Если код ошибки некорректен, информировать пользователя
 // об обнаружении внутренней ошибки.
 // Вернуть статус.
}</p>
<p>Это только начало написания кода. Поскольку используется переменная errorMessage, ее нужно объявить. Если вы вносите комментарии после написания кода, двух строк комментария на две строки кода почти всегда будет достаточно. При данном же подходе важно семантическое содержание комментариев, а не число строк кода, к которым они относятся. Комментарии уже есть и описывают действия кода, так что оставьте их все.</p>
<p>Далее нужно добавить код ко всем оставшимся комментариям:</p>
<p><b>Пример законченного метода, созданного посредством
Процесса Программирования Псевдокода (C++)</b></p>
<p class="preformatted">/* Этот метод выводит сообщение об ошибке на основании кода ошибки, получаемого от
вызывающей программы. Способ вывода сообщения зависит от режима работы, который он
определяет сам. Он возвращает значение, указывающее на успешное завершение или сбой.
*/
Status ReportErrorMessage(
 ErrorCode errorToReport
 ) {
 // Установить статус по умолчанию в “сбой”.
 Status errorMessageStatus = Status_Failure;
 // Найти сообщение, соответствующее коду ошибки.
 Message errorMessage = LookupErrorMessage( errorToReport );
 // Если код ошибки корректен.</p>
<p>Отсюда начинаем добавлять код для каждого комментария.</p>
<p class="preformatted">if ( errorMessage.ValidCode() ) {
 // Определяем метод обработки.
 ProcessingMethod errorProcessingMethod = CurrentProcessingMethod();
 // Если работа в интерактивном режиме, вывести сообщение
 // и указать успешный статус.
 if ( errorProcessingMethod == ProcessingMethod_Interactive ) {
 DisplayInteractiveMessage( errorMessage.Text() );
 errorMessageStatus = Status_Success;
 }
 // Если работа в режиме командной строки, запротоколировать
 // сообщение об ошибке и указать успешный статус.</p>
<p>Этот код — хороший кандидат стать новым методом: DisplayCommandLineMessage().</p>
<p class="preformatted"> else if ( errorProcessingMethod == ProcessingMethod_CommandLine ) {
 CommandLine messageLog;
 if ( messageLog.Status() == CommandLineStatus_Ok ) {
 messageLog.AddToMessageQueue( errorMessage.Text() );
 messageLog.FlushMessageQueue();
 errorMessageStatus = Status_Success;
 }</p>
<p>Эти код и комментарий новые и являются результатом развертывания оператора if.</p>
<p class="preformatted"> else {
 // Не можем ничего делать, так как процедура
 // сама занимается обработкой ошибки.
 }</p>
<p>Это тоже новый код и комментарий.</p>
<p class="preformatted"> else {
 // Не можем ничего делать, так как процедура
 // сама занимается обработкой ошибки.
 }
 }</p>
<p class="preformatted"> // Если код ошибки некорректен, извещаем пользователя
 // об обнаружении внутренней ошибки.
 else {
  DisplayInteractiveMessage(
   “Internal Error: Invalid error code in ReportErrorMessage()”
  );
 }
 // Вернуть статус.
 return errorMessageStatus;
}</p>
<p>К каждому комментарию добавлена одна или несколько строк кода. Каждый блок кода выражает некоторое намерение, описанное комментариями. Все переменные объявлены и определены рядом с местом их первого использования. Каждый комментарий обычно разворачивается в 2–10 строк кода.</p>
<p>Теперь вернемся к спецификации и псевдокоду. Первоначальная спецификация из пяти предложений превратилась в 15 строк псевдокода, которые в свою очередь развернуты в метод размером в страницу. Хотя спецификация и была достаточно подробной, создание метода потребовало проектировочных работ при написании псевдокода и кодировании. Это низкоуровневое проектирование и есть одна из причин, по которой «кодирование» является нетривиальной задачей.</p>
<p><b>Проверьте, не нужна ли дальнейшая декомпозиция кода</b> В некоторых случаях вы увидите, что код, соответствующий одной изначальной строке псевдокода, существенно разросся. В таких ситуациях следует предпринять одно из следующих действий.</p>
<ul>
<li>Преобразуйте код, соответствующий комментарию, в новый метод. Дайте методу имя и напишите код вызова этого метода. Если вы правильно применяли ППП, имя метода вы легко придумаете на основе псевдокода. Закончив работу с изначальным кодом, переходите к вновь созданным методам и применяйте ППП к ним.</li>
<li>Применяйте ППП рекурсивно. Вместо того чтобы писать несколько десятков строк кода для одной строки псевдокода, разбейте эту строку псевдокода на несколько предложений и для каждой из них напишите код.</li>
</ul>
<h4>Проверка кода</h4>
<p>Третий шаг после проектирования и реализации метода — его проверка. Все ошибки, которые вы пропустите на этом этапе, вы сможете обнаружить лишь при позднейшем тестировании, что обойдется вам дороже.</p>
<p>Ошибка может не проявиться до окончательного кодирования по нескольким причинам. Ошибка в псевдокоде может стать заметнее при детальной реализации. Конструкция, выглядящая элегантно в псевдокоде, на языке программирования может стать топорной. Проработка детальной реализации может выявить ошибку архитектуры, проекта или требований. Наконец, код может содержать самые банальные ошибки программирования — никто не совершенен! По всем этим причинам пересмотрите код, прежде чем двигаться дальше.</p>
<p>Умозрительно проверьте ошибки в методе Первая формальная проверка метода — умозрительная. Мысленно выполните все ветви метода. Сделать это непросто, что и является одной из причин писать короткие методы. Проверьте все возможные ветви и исключительные условия. Проделайте это сами и с коллегами.</p>
<p>Одно из основных различий между любителями и профессиональными программистами — различие, появляющееся при переходе от суеверия к пониманию. Под суеверием здесь я понимаю не иллюзию, что программа выдает больше ошибок в полнолуние, а замену «прочувствования» программы ее пониманием. Если вы часто обнаруживаете, что подозреваете компилятор или аппаратные средства в ошибке, вы в плену суеверий. Давнишние исследования показали, что только около 5% всех ошибок связано с аппаратурой, компиляторами или ОС (Ostrand and Weyuker, 1984). Сейчас этот процент, видимо, еще меньше. Программист, достигший сферы понимания, обращает внимание прежде всего на свое творение, являющееся потенциальным источником 95% ошибок. Нужно знать роль каждой строки своей программы. Ничто не может называться верным только потому, что выглядит работоспособным. Если вы не знаете, почему это работает, вероятно, оно и не работает на самом деле.</p>
<p>Итог: работающий метод — это еще не все. Если вы не знаете, как он работает, изучайте его, обсуждайте его, экспериментируйте с альтернативными вариантами, пока не добьетесь понимания.</p>
<p><b>Компиляция метода</b> Проверив метод, скомпилируйте его. Может показаться неэффективным так долго откладывать компиляцию. Вероятно, вы уменьшите себе работу, скомпилировав метод ранее и позволив компилятору проверить необъявленные переменные, обнаружить конфликты имен и т. д.</p>
<p>Между тем, отложив трансляцию на более поздний срок, вы получите ряд преимуществ. Основная причина в том, что, когда вы компилируете новый код, в вас начинают тикать внутренние часики. После первой трансляции появляется мысль: «Еще всего одна компиляция, и дело сделано». Этот синдром «еще всего одной компиляции» подвигает вас к скороспелым, чреватым ошибками изменениям, которые в долгосрочном плане увеличивают общее время работы. Не спешите и не компилируйте программу, пока не будете уверены, что она верна.</p>
<p>Вот несколько советов по эффективной компиляции.</p>
<ul>
<li> Установите наивысший уровень предупреждений компилятора. Вы можете отловить изрядное число ошибок, лишь позволив компилятору их обнаруживать.</li>
<li> Применяйте проверяющие средства. Встроенные проверяющие средства компиляторов могут быть дополнены внешними, такими как lint для С. Даже некомпилируемый код, скажем, HTML и JavaScript, можно проверить соответствующими утилитами.</li>
<li> Выясните причину всех сообщений об ошибках и предупреждений. Подумайте, что сообщение говорит о вашем коде. Многие предупреждения зачастую указывают на низкое качество кода, и вам следует попытаться понять смысл каждого предупреждения. На практике предупреждения, которые вы видите раз за разом, вызывают одну из двух реакций: вы или не обращаете на них внимания, и они скрывают от вашего взгляда более важные предупреждения, или они попросту вас раздражают. Как правило, проще и безболезненней переписать код, решив проблему, вызывающую предупреждения, и, таким образом, избавиться от них.</li>
</ul>
<p><b>Пройдите по коду отладчиком</b> Скомпилировав метод, запустите его в отладчике и пройдите по каждой строке кода. Убедитесь, что каждая строка выполняется так, как вы ожидаете. Следуя этому простому совету, вы сможете найти много ошибок.</p>
<p><b>Протестируйте код</b> Протестируйте код, используя тестовые примеры, которые вы запланировали или уже создали при разработке метода. Возможно, вы создали леса для поддержки тестирования, т. е. код, поддерживающий методы при тестировании и не включаемый в конечный продукт. Леса могут представлять собой методы — тестовые сбруи, которые вызывают ваш метод с тестовыми данными, или заглушки, вызываемые вашим методом.</p>
<p><b>Удалите ошибки из метода</b> Обнаруженные ошибки нужно удалить. Если к этому моменту ваш метод работает нестабильно, велика вероятность, что он таким и останется. Обнаружив непонятное поведение метода, начните все заново. Не пытайтесь доводить его до ума — перепишите его. Изощренные переделки обычно говорят о неполном понимании и гарантируют возникновение ошибок как сейчас, так и в будущем. Полное перепроектирование нестабильного метода полностью оправданно. Мало что сравнится по эффективности с переписыванием проблемного метода — вы позабудете о бывших ошибках.</p>
<h4>Наведение глянца</h4>
<p>Проверив код, оцените его с учетом общих критериев, описанных в этой книге. Чтобы гарантировать соответствие качества метода высоким стандартам, сделайте следующее.</p>
<ul>
<li>Проверьте интерфейс метода. Убедитесь, что применяются все входные и выходные данные и используются все параметры (см. раздел 7.5).</li>
<li>Проверьте общее качество конструкции. Убедитесь, что метод выполняет единственную задачу и делает это хорошо, имея в виду его слабое сопряжение с другими методами и проектирование в соответствии с методикой защитного программирования (см. главу 7).</li>
<li>Проверьте переменные метода: корректность их именования, неиспользуемые объекты, необъявленные переменные, неверно инициализированные объекты и т. д. (см. главы 10–13).</li>
<li>Проверьте логику метода. Проанализируйте наличие ошибок занижения/завышения на 1, некорректной вложенности и утечки ресурсов (см. главы 14–19).</li>
<li>Проверьте форматирование метода. Убедитесь в корректном использовании пробелов для структурирования метода, выражений и списка параметров (см. главу 31).</li>
<li>Проверьте документирование метода. Убедитесь в корректности псевдокода, переведенного в комментарии. Проверьте описание алгоритма, документирование интерфейса, неочевидных зависимостей и нестандартных подходов (см. главу 32).</li>
<li>Удалите лишние комментарии. Иногда комментарии, полученные из псевдокода, являются избыточными, особенно когда ППП применяется рекурсивно и комментарии лишь описывают вызов метода, назначение которого и так понятно из его имени.</li>
</ul>
<h4>Повторите нужное число раз</h4>
<p>Если качество метода неудовлетворительное, вернитесь к псевдокоду. Создание высококачественного ПО — итеративный процесс, так что без колебаний повторяйте весь цикл конструирования вновь и вновь.</p>
	</body>
</html>