<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8"/>
		<link href="styles.css" rel="stylesheet"></link>
	</head>
	<body>
	Цитата из книги "Совершенный код" с комментариями. Автор: С.Макконнел
	<p>Купить всю книгу можно на следующих сайтах:
	<ul>
		<li>ozon.ru <a href="http://www.ozon.ru/context/detail/id/138437220/" target="_blank">(открыть в новой вкладке)</a></li>
		<li>market.yandex.ru <a href="https://market.yandex.ru/product--makkonnell-s-sovershennyi-kod-master-klass/1545077" target="_blank">(открыть в новой вкладке)</a></li>
	</ul>
	</p>
	<h3>Часть II. Отрывок из главы 6.1 "Основы классов: абстрактные типы данных"</h3>
<p>Абстрактный тип данных (АТД) — это набор, включающий данные и выполняемые над ними операции. Операции описывают данные для остальной части программы и позволяют их изменять. Слово «данные» используется в выражении «абстрактный тип данных» довольно условно. АТД может быть графическое окно совсеми влияющими на него операциями, файл с файловыми операциями, таблица страховых тарифов с соответствующими операциями и др.</p>
<p>Понимание концепции АТД необходимо для понимания объектно-ориентированного программирования. Не имея ясного представления об АТД, программисты создают классы, которые только называются «классами», будучи на самом деле лишь удобными контейнерами, содержащими наборы плохо согласующихся друг с другом данных и методов. Понимание АТД облегчает создание классов и их изменение с течением времени.</p>
<p>В книгах по программированию обсуждение АТД традиционно носит математический характер. Довольно часто можно встретить высказывания вроде: «АТД можно понимать как математическую модель с определенным для нее набором операций».
И создается впечатление, что АТД подойдет разве что в качестве снотворного.</p>
<p>Такие сухие объяснения АТД никуда не годятся. АТД удивительны тем, что позволяют работать с сущностями реального мира, а не с низкоуровневыми сущностями реализации. Благодаря этому вместо вставки узла в связный список можно добавить ячейку в электронную таблицу, новый тип окна в список типов окон или очередной пассажирский автомобиль в программу, моделирующую поток движения. Возможность работать в проблемной области, а не в низкоуровневой области реализации программы очень удобна. Используйте ее!</p>
<h4>Пример необходимости АТД</h4>
<p>Для начала приведем пример ситуации, в которой применение АТД было бы полезным. После этого мы сможем углубиться в подробности. Допустим, вы пишете программу, управляющую выводом текста на экран с использованием разнообразных гарнитур шрифтов, их размеров и атрибутов (например, «полужирный» и «курсив»). За работу со шрифтами отвечает конкретная часть программы. При использовании АТД данные — названия гарнитур, размеры и атрибуты шрифтов — будут объединены в одну группу с обрабатывающими их методами. Набор данных и методов, служащих одной цели, — это и есть АТД.</p>
<p>Без АТД вам пришлось бы принять специализированный подход к работе со шрифтами. Скажем, для выбора шрифта размером 12 пт, которым могли бы соответствовать 16 пикселов, вы написали бы что-то вроде:</p>
<p class="preformatted">currentFont.size = 16</p>
<p>Создав набор библиотечных методов, код можно было бы сделать чуть понятнее:</p>
<p class="preformatted">currentFont.size = PointsToPixels( 12 )</p>
<p>Кроме того, атрибуту шрифта можно было бы присвоить более определенное имя, например:</p>
<p class="preformatted">currentFont.sizeInPixels = PointsToPixels( 12 )</p>
<p>Однако при этом вы не смогли бы включить в программу сразу два поля, определяющих размер шрифта: currentFont.sizeInPixels (размер шрифта в пикселах) и currentFont.sizeInPoints (размер шрифта в пунктах), — потому что тогда структура currentFont не смогла бы узнать, какое из них использовать. Кроме того, изменяя размеры шрифтов в нескольких местах, вы распространили бы похожие строки по всей программе.</p>
<p>Для выбора полужирного начертания вы могли бы написать код, использующий логическое ИЛИ и шестнадцатеричную константу 0x02:</p>
<p class="preformatted">currentFont.attribute = currentFont.attribute or 0x02</p>
<p>Этот код можно немного улучшить, но лучшее, что вы получите, используя специализированный подход, будет похоже на:</p>
<p class="preformatted">currentFont.attribute = currentFont.attribute or BOLD</p>
<p>или на что-нибудь такое:</p>
<p class="preformatted">currentFont.bold = True</p>
<p>Как и в случае с размером шрифта, проблема здесь в том, что клиентский код должен контролировать элементы данных непосредственно, а это ограничивает число возможных способов применения структуры currentFont.</p>
<p>Такой подход к программированию способствует распространению похожих строк кода по всей программе.</p>
<h4>Преимущества использования АТД</h4>
<p>Проблема не в том, что специализированный подход — плохая методика программирования. Просто вы можете заменить его на лучшую методику, преимущества которой описаны ниже.</p>
<p><b>Возможность сокрытия деталей реализации</b> Сокрытие информации о типах данных шрифта подразумевает, что при необходимости изменения типа данных вы сможете изменить его в одном месте, не влияя на всю программу. Например, если вы не скроете детали реализации в АТД, то при изменении одного вида представления полужирного шрифта на другой вам придется изменить каждый фрагмент кода, в котором задается полужирное начертание. Сокрытие информации защитит остальную часть программы и в тех случаях, если вы решите хранить данные во внешнем хранилище, а не в памяти или переписать все методы, выполняющие операции над шрифтами, на другом языке.</p>
<p><b>Ограничение области изменений</b> Если вы захотите разнообразить шрифты и реализовать для них дополнительные операции (такие как переключение на надстрочный шрифт, перечеркивание и т. д.), вы сможете изменить один фрагмент кода, и это не повлияет на остальную часть программы.</p>
<p>Более высокая информативность интерфейса Код currentFont.size = 16 неоднозначен, так как число 16 может определять размер шрифта и в пикселах, и в пунктах. Контекст об этом ничего не говорит. Объединение всех похожих операций в АТД позволяет определить весь интерфейс в терминах пунктов, в терминах пикселов или четко разделить оба варианта, помогая избежать путаницы.</p>
<p><b>Легкость оптимизации кода</b> Для повышения быстродействия операций над шрифтами вы сможете переписать несколько четко определенных методов, а не блуждать по всей программе.</p>
<p><b>Легкость проверки кода</b> Нудную проверку правильности команд вида currentFont.attribute = currentFont.attribute or 0x02 вы сможете заменить более простой проверкой правильности вызовов currentFont.SetBoldOn(). В первом случае можно указать неверное имя структуры, неверное имя поля, неверную операцию (and вместо or) или неверное значение атрибута (0x20 вместо 0x02). В случае вызова currentFont. SetBoldOn() ошибкой может быть лишь указание неверного имени метода, так что заметить ее легче.</p>
<p><b>Удобочитаемость и понятность кода</b> Команду вида currentFont.attribute or 0x02 можно улучшить, заменив 0x02 на BOLD (или что там представляет константа 0x02), но даже после этого по удобочитаемости она не сравнится с вызовом метода currentFont.SetBoldOn().</p>
<p>Вудфилд, Дансмор и Шен провели исследование, участники которого — аспиранты и студенты старших курсов факультета информатики — должны были ответить на вопросы о двух программах: одна была разделена на восемь методов в функциональном стиле, а вторая — на восемь методов АТД (Woodfield, Dunsmore, and Shen, 1981). Студенты, отвечавшие на вопросы о второй программе, получили на 30% более высокие оценки.</p>
<p><b>Ограничение области использования данных</b> В только что представленных примерах структуру currentFont нужно изменять непосредственно или передавать в каждый метод, работающий со шрифтами. При использовании АТД вам не пришлось бы ни передавать ее в методы, ни превращать в глобальные данные. АТД просто включал бы структуру, содержащую данные currentFont. Прямой доступ к этим данным имели бы лишь методы из состава АТД, но не какие бы то ни было другие методы.</p>
<p><b>Возможность работы с сущностями реального мира, а не с низкоуровневыми деталями реализации</b> АТД позволяет определить операции над шрифтами так, что большая часть программы будет сформулирована исключительно в терминах шрифтов, а не доступа к массивам, определений структур или значений True и False.</p>
<p>В нашем случае в АТД можно было бы включить методы:</p>
<p class="preformatted">currentFont.SetSizeInPoints( sizeInPoints )
currentFont.SetSizeInPixels( sizeInPixels )
currentFont.SetBoldOn()
currentFont.SetBoldOff()
currentFont.SetItalicOn()
currentFont.SetItalicOff()
currentFont.SetTypeFace( faceName )</p>
<p>Эти методы, вероятно, были бы короткими — пожалуй, они напоминали бы код, приведенный при обсуждении специализированного подхода к управлению шрифтами. Различие двух подходов в том, что, используя АТД, вы изолируете операции над шрифтами в наборе методов, который предоставляет остальным частям программы, работающим с шрифтами, улучшенный уровень абстракции и защищает остальной код от изменений операций над шрифтами.</p>
<h4>Другие примеры АТД</h4>
<p>Допустим, вы разрабатываете приложение, управляющее системой охлаждения ядерного реактора. С системой охлаждения можно работать как с АТД, определив для нее такие операции:</p>
<p class="preformatted">coolingSystem.GetTemperature()
coolingSystem.SetCirculationRate( rate )
coolingSystem.OpenValve( valveNumber )
coolingSystem.CloseValve( valveNumber )</p>
<p>Конкретная реализация данных операций зависела бы от конкретной среды. Остальные фрагменты программы взаимодействовали бы с системой охлаждения при помощи этих методов и могли бы не беспокоиться о внутренних деталях реализации структур данных, их ограничениях, изменениях и т. д.</p>
<p>Вот дополнительные примеры абстрактных типов данных и операций, которые можно было бы для них определить:</p>
<table>
	<tr>
		<th>Система регулирования скорости</th> <th>Кофемолка</th> <th>Топливный бак</th>
	</tr>
	<tr>
		<td>Задать скорость</td><td>Включить</td><td>Заполнить бак</td>
	</tr>
	<tr>
		<td>Получить текущие параметры</td><td>Выключить</td><td>Слить топливо</td>
	</tr>
	<tr>
		<td>Восстановить предыдущее значение скорости</td><td>Задать скорость</td><td>Получить емкость топливного бака</td>
	</tr>
	<tr>
		<td>Отключить систему</td><td>Начать перемалывание кофе</td><td>Получить статус топливного бака</td>
	</tr>
	<tr>
		<td></td><td>Прекратить перемалывание кофе</td><td></td>
	</tr>
	<tr>
		<th>Список</th><td></td><th>Стек</th>
	</tr>
	<tr>
		<td>Инициализировать список</td><th>Фонарь</th><td>Инициализировать стек</td>
	</tr>
	<tr>
		<td>Вставить элемент</td><td>Включить</td><td>Поместить элемент в стек</td>
	</tr>
	<tr>
		<td>Удалить элемент</td><td>Выключить</td><td>Извлечь элемент из стека</td>
	</tr>
	<tr>
		<td>Прочитать следующий элемент</td><td></td><td>Прочитать верхний элемент стека</td>
	</tr>
	<tr>
		<th>Система справочной информации</th><th>Меню</th><th>Файл</th>
	</tr>
	<tr>
		<td>Добавить раздел</td><td>Создать новое меню</td><td>Открыть файл</td>
	</tr>
	<tr>
		<td>Удалить раздел</td><td>Уничтожить меню</td><td>Прочитать файл</td>
	</tr>
	<tr>
		<td>Задать текущий раздел</td><td>Добавить в меню новый элемент</td><td>Записать файл</td>
	</tr>
	<tr>
		<td>Отобразить окно справочной системы</td><td>Удалить элемент меню</td><td>Установить указатель файла</td>
	</tr>
	<tr>
		<td>Уничтожить окно справочной системы</td><td>Активировать элемент меню</td><td>Закрыть файл</td>
	</tr>
	<tr>
		<td>Отобразить указатель информационных разделов</td><td>Деактивировать элемент меню</td><td></td>
	</tr>
	<tr>
		<td>Вернуться к предыдущему разделу</td><td>Отобразить меню</td><th>Лифт</th>
	</tr>
	<tr>
		<td></td><td>Скрыть меню</td><td>Переместиться на один этаж вверх</td>
	</tr>
	<tr>
		<th>Указатель</th><td>Получить индекс выбранного элемента меню</td><td>Переместиться на один этаж вниз</td>
	</tr>
	<tr>
		<td>Выделить блок памяти</td><td></td><td>Переместиться на конкретный этаж</td>
	</tr>
	<tr>
		<td>Освободить блок памяти</td><td></td><td>Сообщить текущий номер этажа</td>
	</tr>
	<tr>
		<td>Изменить объем выделенной памяти</td><td></td><td>Вернуться на первый этаж</td>
	</tr>
</table>
<p>Изучение этих примеров позволяет вывести принципы использования АТД, которые мы и обсудим.</p>
<p><b>Представляйте в форме АТД распространенные низкоуровневые типы данных</b> Обычно при обсуждении АТД речь идет о представлении в форме АТД популярных низкоуровневых типов данных. Как вы могли заметить по примерам, в форме АТД можно представить стек, список, очередь и почти любой другой популярный тип данных.</p>
<p>Спросите себя: «Что представляет этот стек, список или эта очередь?» Если стек представляет набор сотрудников, рассматривайте АТД как набор сотрудников, а не как стек. Если список соответствует набору счетов, рассматривайте его как набор счетов. Если очередь представляет ячейки электронной таблицы, обращайтесь с ней как с набором ячеек, а не обобщенных элементов. Используйте как можно более высокий уровень абстракции.</p>
<p><b>Представляйте в форме АТД часто используемые объекты, такие как файлы</b> Большинство языков включает несколько АТД, которые известны всем программистам, но не всегда воспринимаются как АТД. В качестве примера приведу операции над файлами. При записи данных на диск ОС избавляет вас от забот, связанных с позиционированием головки чтения/записи, выделением новых секторов на диске при заполнении старых и интерпретацией непонятных кодов ошибок. ОС предоставляет первый уровень абстракции и соответствующие ему АТД. Высокоуровневые языки предоставляют второй уровень абстракции и АТД для этого уровня. Высокоуровневые языки скрывают от вас детали генерации вызовов ОС и работы с буферами данных. Они позволяют рассматривать область диска как «файл».</p>
<p>АТД можно разделить на уровни аналогичным образом. Хотите использовать АТД на уровне операций со структурами данных (таких как помещение элементов в стек и их извлечение) — прекрасно, но поверх него можно создать и другой уровень, соответствующий проблеме реального мира.</p>
<p><b>Представляйте в форме АТД даже простые элементы</b> Для оправдания использования АТД не обязательно иметь гигантский тип данных. Одним из АТД в нашем списке примеров был фонарь, поддерживающий только две операции: включение и выключение. Вам может показаться, что создавать для операций «включить» и «выключить» отдельные методы слишком расточительно, однако на самом деле АТД выгодно использовать даже в случае самых простых операций. Представление фонаря и его операций в форме АТД облегчает понимание и изменение кода, ограничивает потенциальные следствия изменений методов TurnLightOn() и TurnLightOff() и снижает число элементов данных, которые нужно передавать в методы.</p>
<p><b>Обращайтесь к АТД так, чтобы это не зависело от среды, используемой для его хранения</b> Допустим, ваша таблица страховых тарифов настолько велика, что ее нужно всегда хранить на диске. Вы могли бы представить ее как «файл тарифов (rate file)» и создать такие методы доступа, как RateFile. Read(). Однако, ссылаясь на таблицу как на файл, вы сообщаете о ней больше информации, чем следовало бы. Если вы когда-нибудь измените программу так, чтобы таблица хранилась в памяти, а не на диске, код, обращающийся к ней как к файлу, станет некорректным и начнет вызывать замешательство. Поэтому старайтесь присваивать классам и методам доступа имена, не зависящие от способа хранения данных, и обращайтесь не к конкретным сущностям, а к АТД, таким как таблица страховых тарифов. В нашем случае класс и метод доступа следовало бы назвать rateTable. Read() или просто rates. Read().</p>
<h4>Работа с несколькими экземплярами данных при использовании АТД в средах, не являющихся объектно-ориентированными</h4>
<p>Объектно-ориентированные языки автоматически поддерживают работу с несколькими экземплярами АТД. Если вы использовали исключительно объектно-ориентированные среды и вам не приходилось реализовывать поддержку работы с несколькими экземплярами данных, можете положиться на свою удачу! (И перейти к следующему разделу — «АТД и классы»).</p>
<p>Если вы программируете на C или другом языке, не являющемся объектно-ориентированным, поддержку работы с несколькими экземплярами данных нужно реализовать вручную. В целом это значит, что вы должны создать для АТД сервисы создания и уничтожения экземпляров данных и спроектировать другие сервисы АТД так, чтобы они могли работать с несколькими экземплярами.</p>
<p>АТД «шрифт» изначально предлагал такие сервисы:</p>
<p class="preformatted">currentFont.SetSize( sizeInPoints )
currentFont.SetBoldOn()
currentFont.SetBoldOff()
currentFont.SetItalicOn()
currentFont.SetItalicOff()
currentFont.SetTypeFace( faceName )</p>
<p>В среде, не являющейся объектно-ориентированной, эти методы не были бы связаны с классом и выглядели бы так:</p>
<p class="preformatted">SetCurrentFontSize( sizeInPoints )
SetCurrentFontBoldOn()
SetCurrentFontBoldOff()
SetCurrentFontItalicOn()
SetCurrentFontItalicOff()
SetCurrentFontTypeFace( faceName )</p>
<p>Если бы вы хотели работать с несколькими шрифтами одновременно, то должны были бы создать сервисы создания и удаления экземпляров шрифтов вроде этих:</p>
<p class="preformatted">CreateFont( fontId )
DeleteFont( fontId )
SetCurrentFont( fontId )</p>
<p>Идентификатор шрифта fontId позволяет следить за несколькими шрифтами по мере их создания и использования. Что касается других операций, то в этом случае вы можете выбирать один из трех вариантов реализации интерфейса АТД.</p>
<ul>
	<li>Вариант 1: явно указывать экземпляр данных при каждом обращении к сервисам АТД. В этом случае «текущий шрифт (current font)» не требуется. В каждый метод, работающий со шрифтами, вы передаете fontId. Методы АТД Font следят за всеми данными шрифта, а клиентский код — лишь за идентификатором fontId. Этот вариант требует, чтобы каждый метод, работающий со шрифтами, принимал дополнительный параметр fontId.</li>
	<li>Вариант 2: явно предоставлять данные, используемые сервисами АТД. В данном случае вы объявляете нужные АТД данные в каждом методе, использующем сервис АТД. Иначе говоря, вы создаете тип данных Font, который передаете в каждый из сервисных методов АТД. Вы должны спроектировать сервисные методы АТД так, чтобы они использовали данные Font, передаваемые в них при каждом вызове. При этом клиентский код не нуждается в идентификаторе шрифта, потому что он следит за данными шрифтов сам. (Хотя данные типа Font доступны напрямую, к ним надо обращаться только через сервисные методы АТД. Это называется поддержанием структуры «в закрытом виде».)</li>
</ul>
<p>Преимущество этого подхода в том, что сервисным методам АТД не приходится просматривать информацию о шрифте, опираясь на его идентификатор. Есть и недостаток: такой способ предоставляет доступ к данным шрифта остальным частям программы, из-за чего повышается вероятность того, что клиентский код будет использовать детали реализации АТД, которым следовало бы оставаться скрытыми внутри АТД.</p>
<ul>
	<li>Вариант 3: использовать неявные экземпляры (с большой осторожностью). Вы должны создать новый сервис — скажем, SetCurrentFont ( fontId ), — при вызове которого заданный экземпляр шрифта делается текущим. После этого все остальные сервисы используют текущий шрифт, благодаря чему в них не нужно передавать параметр fontId. При разработке простых приложений такой подход может облегчить использование нескольких экземпляров данных. В сложных приложениях подобная зависимость от состояния в масштабе всей системы подразумевает, что вы должны следить за текущим экземпляром шрифта во всем коде, вызывающем методы Font; разумеется, сложность программы при этом повышается. Каким бы ни был размер приложения, всегда можно найти более удачные альтернативы данному подходу.</li>
</ul>
<p>Внутри АТД вы можете реализовать работу с несколькими экземплярами данных как угодно, но вне его при использовании языка, не являющегося объектно-ориентированным, возможны только три указанных варианта.</p>
<h4>АТД и классы</h4>
<p>Абстрактные типы данных лежат в основе концепции классов. В языках, поддерживающих классы, каждый АТД можно реализовать как отдельный класс. Однако обычно с классами связывают еще две концепции: наследование и полиморфизм. Можете рассматривать класс как АТД, поддерживающий наследование и полиморфизм.</p>
	</body>
</html>