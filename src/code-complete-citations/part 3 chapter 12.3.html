<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8"/>
		<link href="styles.css" rel="stylesheet"></link>
	</head>
	<body>
	Цитата из книги "Совершенный код" с комментариями. Автор: С.Макконнел
	<p>Купить всю книгу можно на следующих сайтах:
	<ul>
		<li>ozon.ru <a href="http://www.ozon.ru/context/detail/id/138437220/" target="_blank">(открыть в новой вкладке)</a></li>
		<li>market.yandex.ru <a href="https://market.yandex.ru/product--makkonnell-s-sovershennyi-kod-master-klass/1545077" target="_blank">(открыть в новой вкладке)</a></li>
	</ul>
	</p>
	<h3>Часть III. Глава 12.3  Числа с плавающей запятой</h3>
<p>Главная особенность применения чисел с плавающей запятой в том, что многие дробные десятичные числа не могут быть точно представлены с помощью нулей и единиц, используемых в цифровом компьютере. В бесконечных десятичных дробях, таких как 1/3 или 1/7, обычно сохраняется только 7 или 15 цифр после запятой. В моей версии Microsoft Visual Basic 32-бит-ное представление дроби 1/3 в виде числа с плавающей запятой равно 0,33333330. То есть точность ограничена 7 цифрами. Такая точность достаточна для большинства случаев, но все же способна иногда вводить в заблуждение.</p>
<p>Вот несколько рекомендаций по использованию чисел с плавающей запятой.</p>
<p><b>Избегайте сложения и вычитания слишком разных по размеру чисел</b> Для 32-битной переменной с плавающей запятой сумма 1 000 000,00 + 0,1, вероятно, будет равна 1 000 000,00, так как в 32 битах недостаточно значимых цифр, чтобы охватить интервал между 1 000 000 и 0,1. Аналогично 5 000 000,02 – 5 000 000,01, вероятно, равно 0,0.</p>
<p>Решение? Если вам нужно складывать настолько разные по величине числа, сначала отсортируйте их, а затем складывайте, начиная с самых маленьких значений. Аналогично, если вам надо сложить бесконечный ряд значений, начните с наименьшего члена, т. е. суммируйте члены в обратном порядке. Это не решит проблемы округления, но минимизирует их. Многие алгоритмические книги предлагают решения для таких случаев.</p>
<p><b>Избегайте сравнений на равенство</b> Числа с плавающей запятой, которые должны быть равны, на самом деле равны не всегда. Главная проблема в том, что два разных способа получить одно и то же число не всегда приводят к одинаковому результату. Так, если 10 раз сложить 0,1, то 1,0 получается только в редких случаях. Следующий пример содержит две переменных (nominal и sum), которые должны быть равны, но это не так.</p>
<p>Пример неправильного сравнения чисел с плавающей точкой (Java)</p>
<p class="preformatted">//Переменная nominal — 64-битное вещественное число.
double nominal = 1.0;
double sum = 0.0;
for ( int i = 0; i &lt; 10; i++ ) {
//sum вычисляется как 10*0,1. Она должна быть равна 1,0.
 sum += 0.1;
}
//Здесь неправильное сравнение.
if ( nominal == sum ) {
 System.out.println( “Numbers are the same.” );
}
else {
 System.out.println( “Numbers are different.” );
}</p>
<p>Как вы, наверное, догадались, программа выводит:</p>
<p class="preformatted">Numbers are different.</p>
<p>Вывод каждого значения sum в цикле for выглядит так:</p>
<p class="preformatted">0.1
0.2
0.30000000000000004
0.4
0.5
0.6
0.7
0.7999999999999999
0.8999999999999999
0.9999999999999999</p>
<p>Таким образом, хорошей идеей будет найти альтернативу операции сравнения на равенство для чисел с плавающей запятой. Один эффективный подход состоит в том, чтобы определить приемлемый интервал точности, а затем использовать логические функции для выяснения, достаточно ли близки сравниваемые значения. Для этого обычно пишется функция Equals(), которая возвращает true, если значения попадают в этот интервал, и false — в противном случае. На языке Java такая функция может выглядеть так:</p>
<p>Пример метода для сравнения чисел с плавающей запятой (Java)</p>
<p class="preformatted">final double ACCEPTABLE_DELTA = 0.00001;
boolean Equals( double Term1, double Term2 ) {
 if ( Math.abs( Term1 - Term2 ) &lt; ACCEPTABLE_DELTA ) {
 return true;
 }
 else {
 return false;
 }
}</p>
<p>Если код в примере «неправильного сравнения чисел с плавающей запятой» изменить так, чтобы для сравнения использовался этот метод, новое выражение получит следующий вид:
<p class="preformatted">if ( Equals( Nominal, Sum ) ) ...</p>
<p>При запуске теста программа выведет сообщение:</p>
<p class="preformatted">Numbers are the same.</p>
<p>В зависимости от требований вашего приложения использование жестко закодированного значения ACCEPTABLE_DELTA может быть недопустимо. Возможно, придется вычислять ACCEPTABLE_DELTA на основании размера двух сравниваемых чисел.</p>
<p><b>Предупреждайте ошибки округления</b> Проблемы с ошибками округления сходны с проблемами слишком разных по размеру чисел. У них одинаковые причины и похожие методики решения. Кроме того, далее перечислены способы решения проблем округления.</p>
<ul>
	<li>Измените тип переменной на тип с большей точностью. Если вы используете числа с одинарной точностью, замените их числами с двойной точностью и т. д.</li>
	<li>Используйте двоично-десятичные переменные (binary coded decimal, BCD). BCD-числа обычно работают медленнее и требуют больше памяти для хранения, но предотвращают множество ошибок округления. Это особенно важно, если используемые переменные представляют собой доллары и центы или другие величины, которые должны точно балансироваться.</li>
	<li>Измените тип с плавающей запятой на целые значения. Это такая самодельная замена BCD-переменных. Возможно, вам придется использовать 64-битные целые, чтобы получить нужную точность. Этот способ предполагает, что вы сами будете отслеживать дробные части чисел. Допустим, изначально вы вели учет денежных сумм, применяя числа с плавающей запятой, при этом центы указывались как дробная часть. Это обычный способ обработки долларов и центов. Когда вы переключаетесь на целые числа, вам нужно вести учет центов с помощью целых, а долларов — с помощью чисел, кратных 100 центам. Иначе говоря, вы умножаете сумму в долларах на 100 и храните центы в этой переменной в интервале от 0 до 99. Такое решение может показаться абсурдным, но оно эффективно и с точки зрения скорости, и с точки зрения точности. Вы можете упростить эти манипуляции, создав класс DollarsAndCents, скрывающий целое представление чисел и предоставляющий необходимые числовые операции.</li>
</ul>
<p><b>Проверяйте поддержку специальных типов данных в языке и дополнительных библиотеках</b> Некоторые языки, включая Visual Basic, предоставляют такие типы данных, как Currency, предназначенные для данных, чувствительных к ошибкам округления. Если ваш язык содержит встроенный тип данных, предоставляющий такую функциональность, используйте его!</p>
	</body>
</html>