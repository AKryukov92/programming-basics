<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8"/>
		<link href="styles.css" rel="stylesheet"></link>
	</head>
	<body>
	Цитата из книги "Совершенный код" с комментариями. Автор: С.Макконнел
	<p>Купить всю книгу можно на следующих сайтах:
	<ul>
		<li>ozon.ru <a href="http://www.ozon.ru/context/detail/id/138437220/" target="_blank">(открыть в новой вкладке)</a></li>
		<li>market.yandex.ru <a href="https://market.yandex.ru/product--makkonnell-s-sovershennyi-kod-master-klass/1545077" target="_blank">(открыть в новой вкладке)</a></li>
	</ul>
	</p>
	<h3>Часть III. Глава 11.2 "Именование конкретных типов данных"</h3>
<p>При именовании конкретных типов данных следует руководствоваться не только общими, но и специфическими соображениями. Ниже описаны принципы именования индексов циклов, переменных статуса, временных переменных, булевых переменных, перечислений и именованных констант</p>
<h4>Именование индексов циклов</h4>
<p>Принципы именования индексов циклов возникли потому, что циклы относятся к самым популярным конструкциям. Как правило, в качестве индексов циклов используют переменные i, j и k:</p>
<p>Пример простого имени индекса цикла (Java)</p>
<p class="preformatted">for ( i = firstItem; i &lt; lastItem; i++ ) {
    data[ i ] = 0;
}</p>
<p>Если же переменную предполагается использовать вне цикла, ей следует присвоить более выразительное имя. Например, переменную, хранящую число записей, прочитанных из файла, можно было бы назвать recordCount:</p>
<p>Пример удачного описательного имени индекса цикла (Java)</p>
<p class="preformatted">recordCount = 0;
while ( moreScores() ) {
    score[ recordCount ] = GetNextScore();
    recordCount++;
}
// строки, в которых используется переменная recordCount
...</p>
<p>Если цикл длиннее нескольких строк, смысл переменной i легко забыть, поэтому в подобной ситуации лучше присвоить индексу цикла более выразительное имя.Так как код очень часто приходится изменять, модернизировать и копировать в другие программы, многие опытные программисты вообще не используют имена вроде i.</p>
<p>Одна из частых причин увеличения циклов — их вложение в другие циклы. Если у вас есть несколько вложенных циклов, присвойте индексам более длинные имена, чтобы сделать код более понятным:</p>
<p>Пример удачного именования индексов вложенных циклов (Java)</p>
<p class="preformatted">for ( teamIndex = 0; teamIndex &lt; teamCount; teamIndex++ ) {
    for ( eventIndex = 0; eventIndex &lt; eventCount[ teamIndex ]; eventIndex++ ) {
         score[ teamIndex ][ eventIndex ] = 0;
    }
}</p>
<p>Тщательный выбор имен индексов циклов позволяет избежать путаницы индексов — использования i вместо j и наоборот. Кроме того, это облегчает понимание операций над массивами: команда score[ teamIndex ][ eventIndex ] более информативна, чем score[ i ][ j ].</p>
<p>Не присваивайте имена i, j и k ничему, кроме индексов простых циклов: нарушение этой традиции только запутает других программистов. Чтобы избежать подобных проблем, просто подумайте о более описательных именах, чем i, j и k</p>


<h4>Именование переменных статуса</h4>
<p>Переменные статуса характеризуют состояние программы. Ниже рассмотрен один принцип их именования.</p>
<p><b>Старайтесь не присваивать переменной статуса имя flag</b> Наоборот, рассматривайте флаги как переменные статуса. Имя флага не должно включать фрагмент flag, потому что он ничего не говорит о сути флага. Ради ясности флагам следует присваивать выразительные значения, которые лучше сравнивать со значениями перечислений, именованных констант или глобальных переменных, выступающих в роли именованных констант. Вот примеры неудачных имен флагов:</p>
<p>Примеры загадочных флагов (C++)</p>
<p class="preformatted">if ( flag ) ...
if ( statusFlag & 0x0F ) ...
if ( printFlag == 16 ) ...
if ( computeFlag == 0 ) ...
flag = 0x1;
statusFlag = 0x80;
printFlag = 16;
computeFlag = 0;</p>
<p>Команды вида statusFlag = 0x80 будет совершенно непонятны, пока вы не поясните в коде или в документации, что такое statusFlag и 0x80. Вот более понятный эквивалентный фрагмент:</p>
<p>Примеры более грамотного использования переменных статуса (C++)</p>
<p class="preformatted">if ( dataReady ) ...
if ( characterType & PRINTABLE_CHAR ) ...
if ( reportType == ReportType_Annual ) ...
if ( recalcNeeded == True ) ...
dataReady = true;
characterType = CONTROL_CHARACTER;
reportType = ReportType_Annual;
recalcNeeded = false;</p>
<p>Очевидно, что команда characterType = CONTROL_CHARACTER выразительнее, чем statusFlag = 0x80. Аналогично условие if ( reportType == ReportType_Annual ) понятнее, чем if ( printFlag == 16 ). Второй фрагмент показывает, что данный подход применим к перечислениям и предопределенным именованным константам. Вот как с помощью именованных констант и перечислений можно было бы задать используемые в нашем примере значения:</p>
<p>Объявление переменных статуса (C++)</p>
<p class="preformatted">// возможные значения переменной CharacterType
const int LETTER = 0x01;
const int DIGIT = 0x02;
const int PUNCTUATION = 0x04;
const int LINE_DRAW = 0x08;
const int PRINTABLE_CHAR = ( LETTER | DIGIT | PUNCTUATION | LINE_DRAW );
260 ЧАСТЬ III Переменные
const int CONTROL_CHARACTER = 0x80;
// возможные значения переменной ReportType
enum ReportType {
    ReportType_Daily,
    ReportType_Monthly,
    ReportType_Quarterly,
    ReportType_Annual,
    ReportType_All
};</p>
<p>Если вам трудно понять какой-то фрагмент кода, подумайте о переименовании переменных. В отличие от детективных романов код программ не должен содержать загадок. Его нужно просто читать.</p>


<h4>Именование временных переменных</h4>
<p>Временные переменные служат для хранения промежуточных результатов вычислений и служебных значений программы. Обычно им присваивают имена temp, x или какие-нибудь другие столь же неопределенные и неописательные имена. В целом использование временных переменных говорит о том, что программист еще не полностью понял проблему. Кроме того, с переменными, официально получившими «временный» статус, программисты обычно обращаются небрежнее, чем с другими переменными, что повышает вероятность ошибок. Относитесь к «временным» переменным с подозрением Часто значение нужно на некоторое время сохранить. Однако в том или ином смысле временными являются почти все переменные. Называя переменную временной, подумайте, до конца ли вы понимаете ее реальную роль. Рассмотрим пример:</p>
<p>Пример неинформативного имени «временной» переменной (C++)</p>
<p class="preformatted">// Вычисление корней квадратного уравнения.
// Предполагается, что дискриминант (b^2-4*a*c) неотрицателен.
temp = sqrt( b^2 - 4*a*c );
root[0] = ( -b + temp ) / ( 2 * a );
root[1] = ( -b - temp ) / ( 2 * a );</p>
<p>Значение выражения sqrt( b^2 - 4 * a * c ) вполне разумно сохранить в переменной, особенно если учесть, что оно используется позднее. Но имя temp ничего не говорит о роли переменной. Лучше поступить так:</p>
<p>Пример замены «временной» переменной на реальную переменную (C++)</p>
<p class="preformatted">// Вычисление корней квадратного уравнения.
// Предполагается, что дискриминант (b^2-4*a*c) неотрицателен.
discriminant = sqrt( b^2 - 4*a*c );
root[0] = ( -b + discriminant ) / ( 2 * a );
root[1] = ( -b - discriminant ) / ( 2 * a );</p>
<p>По сути это тот же код, только в нем использована переменная с точным описательным именем.</p>


<h4>Именование булевых переменных</h4>
<p>Ниже я привел ряд рекомендаций по именованию булевых переменных.</p>
<p><b>Помните типичные имена булевых переменных</b> Вот некоторые наиболее
полезные имена булевых переменных.</p>
<ul>
	<li>done Используйте переменную done как признак завершения цикла или другой операции. Присвойте ей false до выполнения действия и установите ее в true после его завершения.</li>
	<li>error Используйте переменную error как признак ошибки. Присвойте ей значение false, если все в порядке, и true в противном случае.</li>
	<li>found Используйте переменную found для определения того, обнаружено ли некоторое значение. Установите ее в false, если значение не обнаружено, и в true, как только значение найдено. Используйте переменную found при поиске значения в массиве, идентификатора сотрудника в файле, определенного чека в списке чеков и т. д.</li>
	<li>success или ok Используйте переменную success или ok как признак успешного завершения операции. Присвойте ей false, если операция завершилась неудачей, и true, если операция выполнена успешно. Если можете, замените имя success на более определенное, ясно определяющее смысл «успеха». Если под «успехом» понимается завершение обработки данных, можете назвать переменную processingComplete. Если «успех» подразумевает обнаружение конкретного значения, можете использовать переменную found.</li>
</ul>
<p><b>Присваивайте булевым переменным имена, подразумевающие значение
true или false</b> Имена вроде done и success — хорошие имена булевых переменных, потому что они предполагают использование только значений true или false: что-то может быть или выполнено, или не выполнено, операция может завершиться или успехом, или неудачей. С другой стороны, имена вроде status и sourceFile не годятся, так как при этом значения true или false не имеют ясного смысла. Какой вывод можно сделать, если переменной status задано true? Означает ли это, что что-то имеет статус? Все имеет статус. Означает ли это, что что-то имеет статус «все в порядке»? Означает ли значение false, что никакое действие не было выполнено неверно? Если переменная имеет имя status, ничего определенного на сей счет сказать нельзя.</p>
<p>Поэтому имя status лучше заменить на имя вроде error или statusOK, а имя sourceFile — на sourceFileAvailable, sourceFileFound или подобное имя, соответствующее сути переменной.</p>
<p>Некоторые программисты любят дополнять имена булевых переменных префиксом is. В результате имя переменной превращается в вопрос: isdone? isError? isFound? isProcessingComplete? Ответ на этот вопрос сразу становится и значением переменной. Достоинство этого подхода в том, что он исключает использование неопределенных имен: вопрос isStatus? не имеет никакого смысла. Однако в то же время он затрудняет чтение логических выражений: например, условие if ( isFound ) менее понятно, чем if ( found ).</p>
<p><b>Используйте утвердительные имена булевых переменных</b> Имена, основанные на отрицании (такие как notFound, notdone и notSuccessful), при выполнении над переменной операции отрицания становятся куда менее понятны, например:</p>
<p class="preformatted">if not notFound</p>
<p>Подобные имена следует заменить на found, done и processingComplete, выполняя отрицание переменных в случае надобности. Так что для проверки нужного значения вы использовали бы выражение found, а не not notFound.</p>


<h4>Именование перечислений</h4>
<p>Принадлежность переменных к тому или иному перечислению можно пояснить, дополнив их имена префиксами, такими как Color_, Planet_ или Month_:</p>
<p>Пример дополнения элементов перечислений префиксами (Visual Basic)</p>
<p class="preformatted">Public Enum Color
    Color_Red
    Color_Green
    Color_Blue
End Enum
Public Enum Planet
    Planet_Earth
    Planet_Mars
    Planet_Venus
End Enum
Public Enum Month
    Month_January
    Month_February
    ...
    Month_December
End Enum</p>
<p>Кроме того, сами перечисления (Color, Planet или Month) можно идентифицировать разными способами: например, используя в их именах только заглавные буквы или дополняя их имена префиксами (e_Color, e_Planet или e_Month). Кое-кто мог бы сказать, что перечисление по сути является типом, определяемым пользователем, поэтому имена перечислений надо форматировать так же, как имена классов и других пользовательских типов. С другой стороны, члены перечислений являются константами, поэтому имена перечислений следует форматировать как имена констант. В этой книге я придерживаюсь конвенции, предусматривающей применение в именах перечислений букв обоих регистров.</p>
<p>В некоторых языках перечисления рассматриваются скорее как классы, а именам членов перечисления всегда предшествует имя самого перечисления, например, Color.Color_Red или Planet.Planet_Earth. Если вы используете подобный язык, повторять префикс не имеет смысла, так что вы можете считать префиксом само имя перечисления и сократить имена до Color.Red и Planet.Earth.</p>


<h4>Именование констант</h4>
<p>Имя константы должно характеризовать абстрактную сущность, представляемую константой, а не конкретное значение. Имя FIVE — плохое имя константы (независимо от того, имеет ли она значение 5.0). CYCLES_NEEDED — хорошее имя. CYCLES_NEEDED может иметь значение 5.0, 6.0 и любое другое. Выражение FIVE = 6.0 было бы странным. Аналогично BAKERS_DOZEN — плохое имя константы, а DONUTS_MAX — вполне подходящее.</p>
	</body>
</html>