<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8"/>
		<link href="styles.css" rel="stylesheet"></link>
	</head>
	<body>
	Цитата из книги "Совершенный код" с комментариями. Автор: С.Макконнел
	<p>Купить всю книгу можно на следующих сайтах:
	<ul>
		<li>ozon.ru <a href="http://www.ozon.ru/context/detail/id/138437220/" target="_blank">(открыть в новой вкладке)</a></li>
		<li>market.yandex.ru <a href="https://market.yandex.ru/product--makkonnell-s-sovershennyi-kod-master-klass/1545077" target="_blank">(открыть в новой вкладке)</a></li>
	</ul>
	</p>
	<h3>Часть III. Глава 11.1 Общие принципы выбора имен переменных</h3>
<p>Имя переменной нельзя выбирать, как кличку собаке: опираясь на его вычурность или звучание. В отличие от собаки и ее клички, которые являются разными сущностями, переменная и ее имя формируют по идее одну сущность. Поэтому и адекватность переменной во многом определяется ее именем. Выбирайте имена переменных со всей тщательностью.</p>
<p>В следующем примере переменные названы плохо:</p>
<p>Пример неудачного именования переменных (Java)</p>
<p class="preformatted">x = x - xx;
xxx = fido + SalesTax( fido );
x = x + LateFee( x1, x ) + xxx;
x = x + Interest( x1, x );</p>
</p>
<p>Что происходит в этом фрагменте кода? Что означают имена x1, xx и xxx? А fido? Допустим, кто-то сказал вам, что этот код подсчитывает общую сумму предъявляемого клиенту счета, опираясь на его долг и стоимость новых покупок. Какую
переменную вы использовали бы для распечатки общей стоимости только новых покупок?</p>
<p>Взглянув на исправленный вариант того же кода, ответить на этот вопрос куда проще:</p>
<p>Пример удачного именования переменных (Java)</p>
<p class="preformatted">balance = balance - lastPayment;
monthlyTotal = newPurchases + SalesTax( newPurchases );
balance = balance + LateFee( customerID, balance ) + monthlyTotal;
balance = balance + Interest( customerID, balance );</p>
<p>Из сравнения этих фрагментов можно сделать вывод, что хорошее имя переменной адекватно ее характеризует, легко читается и хорошо запоминается. Чтобы облегчить себе достижение этих целей, соблюдайте несколько общих правил.</p>
<h4>Самый важный принцип именования переменных</h4>
<p>Важнейший принцип именования переменных состоит в том, что имя должно полно и точно описывать сущность, представляемую переменной. Один эффективный способ выбора хорошего имени предполагает формулирование сути переменной в словах. Оптимальным именем переменной часто оказывается само это высказывание. Благодаря отсутствию загадочных сокращений оно удобочитаемо; к тому же оно однозначно. Так как оно является полным описанием сущности, его нельзя спутать с чем-либо другим. Наконец, такое имя легко запомнить, потому что оно похоже на исходную концепцию.</p>
<p>Переменную, представляющую число членов олимпийской команды США, можно было бы назвать numberOfPeopleOnTheUsOlympicTeam. Переменную, представляющую число мест на стадионе, — numberOfSeatsInTheStadium. Для хранения максимального числа очков, набранных спортсменами какой-то страны в современной Олимпиаде, можно было бы создать переменную maximumNumberOfPointsInModernOlympics. Переменную, определяющую текущую процентную ставку, лучше было бы назвать rate или interestRate, а не r или x. Думаю, идею вы поняли. Обратите внимание на две характеристики этих имен. Во-первых, их легко расшифровать. Фактически их не нужно расшифровывать вообще: их можно просто прочитать. Ну, а во-вторых, некоторые имена велики — слишком велики, чтобы быть практичными. Длину имен переменных мы рассмотрим ниже.
Несколько примеров удачных и неудачных имен переменных я привел в табл. 11-1</p>
<table class="check_values">
	<tr>
		<th></th>
		<th>Суть переменной</th>
		<th>Удачные имена, адекватное описание</th>
		<th>Неудачные имена, неадекватное описание</th>
	</tr>
	<tr>
		<td></td>
		<td>Сумма, на которую на данный момент выписаны чеки</td>
		<td>runningTotal, checkTotal</td>
		<td>written, ct, checks, CHKTTL, x, x1, x2</td>
	</tr>
	<tr>
		<td></td>
		<td>Скорость поезда</td>
		<td>velocity, trainVelocity, velocityInMph</td>
		<td>velt, v, tv, x, x1, x2, train</td>
	</tr>
	<tr>
		<td></td>
		<td>Текущая дата</td>
		<td>currentDate, todaysDate</td>
		<td>cd, current, c, x, x1, x2, date</td>
	</tr>
	<tr>
		<td></td>
		<td>Число строк на странице</td>
		<td>linesPerPage</td>
		<td>lpp, lines, l, x, x1, x2</td>
	</tr>
</table>
<p>Имена currentDate и todaysDate — хорошие имена, потому что полно и точно описывают идею «текущей даты». Фактически они составлены из слов с очевидным значением. Программисты иногда упускают из виду обычные слова, которые порой приводят к самому простому решению. Имена cd и c неудачны потому, что слишком коротки и «неописательны». Имя current тоже неудачно: оно не говорит, что именно является «текущим». Имя date кажется хорошим, но в итоге оно оказывается плохим, потому что мы имеем в виду не любую дату, а текущую; само по себе имя date об этом не говорит. Имена x, x1 и x2 заведомо неудачны: x традиционно представляет неизвестное количество чего-либо, и, если вы не хотите, чтобы ваши переменные были неизвестными величинами, подумайте о выборе других имен.</p>
<p>Имена должны быть максимально конкретны. Имена x, temp, i и другие, достаточно общие для того, чтобы их можно было использовать более чем с одной целью, не так информативны, как могли бы быть, и обычно являются плохими.</p>
<h4>Ориентация на проблему</h4>
<p>Хорошее мнемоническое имя чаще всего описывает проблему, а не ее решение. Хорошее имя в большей степени выражает что, а не как. Если же имя описывает некоторый аспект вычислений, а не проблемы, имеет место обратное. Предпочитайте таким именам переменных имена, характеризующие саму проблему.</p>
<p>Запись данных о сотруднике можно было бы назвать inputRec или employeeData. Имя inputRec — компьютерный термин, выражающий идеи ввода данных и записи. Имя employeeData относится к проблемной области, а не к миру компьютеров. В случае битового поля, определяющего статус принтера, имя bitFlag более компьютеризировано, чем printerReady, а в случае приложения бухгалтерского учета calcVal более компьютеризировано, чем sum</p>
<h4>Оптимальная длина имени переменной</h4>
<p>Оптимальная длина имени, наверное, лежит где-то между длинами имен x и maximumNumberOfPointsInModernOlympics. Слишком короткие страдают от недостатка смысла. Проблема с именами вроде x1 и x2 в том, что, даже узнав, что такое x,вы ничего не сможете сказать об отношении между x1 и x2. Слишком длинные имена надоедает печатать, к тому же они могут сделать неясной визуальную структуру программы.</p>
<p>Горла, Бенандер и Бенандер обнаружили, что отладка программы требовала меньше всего усилий, если имена переменных состояли в среднем из 10–16 символов (Gorla, Benander, and Benander, 1990). Отладка программ с именами, состоящими в среднем из 8–20 символов, была почти столь же легкой. Это не значит, что следует присваивать всем переменным имена из 9–15
или 10–16 символов, — это значит, что, увидев в своем коде много более коротких имен, вы должны проверить их ясность.</p>
<p>Вопрос адекватности длины имен переменных поясняет табл. 11-2.</p>
<table class="check_values">
	<tr>
		<th>Слишком длинные имена:</th>
		<td>numberOfPeopleOnTheUsOlympicTeam<br>
numberOfSeatsInTheStadium<br>
maximumNumberOfPointsInModernOlympics</td>
	</tr>
	<tr>
		<th>Слишком короткие имена:</th>
		<td>n, np, ntm<br>
n, ns, nsisd<br>
m, mp, max, points</td>
	</tr>
	<tr>
		<th>То, что надо:</th>
		<td>numTeamMembers, teamMemberCount<br>
numSeatsInStadium, seatCount<br>
teamPointsMax, pointsRecord</td>
	</tr>
</table>
<h4>Имена переменных и область видимости</h4>
<p>Всегда ли короткие имена переменных неудачны? Нет, не всегда. Если вы присваиваете переменной короткое имя, такое как i, сама длина имени говорит о том, что переменная является второстепенной и имеет ограниченную область действия.</p>
<p>Программист, читающий код, сможет догадаться, что использование такой переменной ограничивается несколькими строками кода. Присваивая переменной имя i, вы говорите: «Эта переменная — самый обычный счетчик цикла/индекс массива, не играющий никакой роли вне этих нескольких строк».</p>
<p>У. Дж. Хансен (W. J. Hansen) обнаружил, что более длинные имена лучше присваивать редко используемым или глобальным переменным, а более короткие — локальным переменным или переменным, вызываемым в циклах (Shneiderman, 1980). Однако с короткими именами связано много проблем, и некоторые осмотрительные программисты, придерживающиеся политики защитного программирования, вообще избегают их.</p>
<p><b>Дополняйте имена, относящиеся к глобальному пространству имен, спецификаторами</b> Если у вас есть переменные, относящиеся к глобальному пространству имен (именованные константы, имена классов и т. д.), подумайте, принять ли конвенцию, разделяющую глобальное пространство имен на части и предотвращающую конфликты имен. В C++ и C# для разделения глобального пространства имен можно применить ключевое слово namespace:</p>
<p>Пример разделения глобального пространства имен с помощью ключевого слова namespace (C++)</p>
<p class="preformatted">namespace UserInterfaceSubsystem {
 ...
 // объявления переменных
 ...
}
namespace DatabaseSubsystem {
 ...
 // объявления переменных
 ...
}</p>
Если класс Employee объявлен в обоих пространствах имен, вы можете указать нужное пространство имен, написав UserInterfaceSubsystem::Employee или DatabaseSubsystem::Employee. В Java с той же целью можно использовать пакеты.</p>
<p>Программируя на языке, не поддерживающем пространства имен или пакеты, вы все же можете принять конвенции именования для разделения глобального пространства имен. Скажем, вы можете дополнить глобальные классы префиксами, определяющими подсистему. Класс Employee из подсистемы пользовательского интерфейса можно было бы назвать uiEmployee, а тот же класс из подсистемы доступа к БД — dbEmployee. Это позволило бы свести к минимуму риск конфликтов в глобальном пространстве имен.</p>
<h4>Спецификаторы вычисляемых значений</h4>
<p>Многие программы включают переменные, содержащие вычисляемые значения: суммы, средние величины, максимумы и т. д. Дополняя такое имя спецификатором вроде Total, Sum, Average, Max, Min, Record, String или Pointer, укажите его в конце имени. У такого подхода несколько достоинств.</p>
<p>Во-первых, при этом самая значимая часть имени переменной, определяющая наибольшую часть его смысла, располагается в самом начале имени, из#за чего становится более заметной и читается первой. Во#вторых, приняв эту конвенцию, вы предотвратите путаницу, возможную при наличии в одной программе имен totalRevenue и revenueTotal. Эти имена семантически эквивалентны, и конвенция не позволила бы использовать их как разные.</p>
<p>В-третьих, набор имен вроде revenueTotal, expenseTotal, revenueAverage и expenseAverage обладает приятной глазу симметрией, тогда как набор имен totalRevenue, expenseTotal, revenueAverage и averageExpense упорядоченным не кажется.</p>
<p>Наконец, согласованность имен облегчает чтение и сопровождение программы. Исключение из этого правила — позиция спецификатора Num. При расположении в начале имени спецификатор Num обозначает общее число: например, numCustomers — это общее число заказчиков. Если же он указан в конце имени, то определяет индекс: так, customerNum — это номер текущего заказчика. Другим признаком данного различия является буква s в конце имени numCustomers. Однако даже в этом случае спецификатор Num очень часто приводит к замешательству, поэтому лучше всего полностью исключить проблему, применив Count или Total для обозначения общего числа заказчиков и Index для ссылки на конкретного заказчика. Таким образом, переменные, определяющие общее число заказчиков и номер конкретного заказчика, получили бы имена customerCount и customerIndex соответственно.</p>
<p>Антонимы, часто встречающиеся в именах переменных Используйте антонимы последовательно. Это делает код более согласованным и облегчает его чтение. Пары вроде begin/
end понять и запомнить легко. Пары, не соответствующие общепринятым антонимам, запоминаются сложнее и вызывают замешательство. В число антонимов, часто используемых в именах переменных, входят:
<ul>
<li>begin/end</li>
<li>first/last</li>
<li>locked/unlocked</li>
<li>min/max</li>
<li>next/previous</li>
<li>old/new</li>
<li>opened/closed</li>
<li>visible/invisible</li>
<li>source/target</li>
<li>source/destination</li>
<li>up/down</li>
</ul>
</p>
	</body>
</html>