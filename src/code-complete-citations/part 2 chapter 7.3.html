<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8"/>
		<link href="styles.css" rel="stylesheet"></link>
	</head>
	<body>
	Цитата из книги "Совершенный код" с комментариями. Автор: С.Макконнел
	<p>Купить всю книгу можно на следующих сайтах:
	<ul>
		<li>ozon.ru <a href="http://www.ozon.ru/context/detail/id/138437220/" target="_blank">(открыть в новой вкладке)</a></li>
		<li>market.yandex.ru <a href="https://market.yandex.ru/product--makkonnell-s-sovershennyi-kod-master-klass/1545077" target="_blank">(открыть в новой вкладке)</a></li>
	</ul>
	</p>
	<h3>Часть II. Глава 7.3 "Удачные имена методов"</h3>
<p>Имя метода должно ясно описывать все, что он делает. Советы по выбору удачных имен методов приведены ниже.</p>
<p><b>Описывайте все, что метод выполняет</b> Опишите в имени метода все выходные данные и все побочные эффекты. Если метод вычисляет сумму показателей в отчете и открывает выходной файл, имя ComputeReportTotals() не будет адекватным. ComputeReportTotalsAndOpenOutputFile() — имя адекватное, но слишком длинное и несуразное. Создавая методы с побочными эффектами, вы получите много длинных несуразных имен. Выход из этого положения — не использование менее описательных имен, а создание ясных методов без побочных эффектов.</p>
<p><b>Избегайте невыразительных и неоднозначных глаголов</b> Некоторые глаголы могут описывать практически любое действие. Имена вроде HandleCalculation(), PerformServices(), OutputUser(), ProcessInput() и DealWithOutput() не говорят о работе методов почти ничего. В лучшем случае по этим именам можно догадаться, что методы имеют какое-то отношение к вычислениям, сервисам, пользователям, вводу и выводу соответственно. Исключением было бы использование глагола «handle» в специфическом техническом смысле обработки события.</p>
<p>Иногда единственным недостатком метода является невыразительность его имени; сам метод при этом может быть спроектирован очень хорошо. Если имя HandleOutput() заменить на FormatAndPrintOutput(), роль метода станет очевидной.</p>
<p>В других случаях невыразительность глагола в имени метода может объясняться аналогичным поведением метода. Неясная цель — невыразительное имя. Если это так, лучше всего выполнить реструктуризацию метода и всех родственных методов, чтобы все они получили более четкие цели и более выразительные имена, точно их описывающие.</p>
<p>Не используйте для дифференциации имен методов исключительно номера Один разработчик написал весь свой код в форме единственного объемного метода. Затем он разбил код на фрагменты по 15 строк и создал методы Part1, Part2 и т. д. После этого он создал один высокоуровневый метод, вызывающий каждую часть кода. Подобный способ создания и именования методов глуп до невозможности (и столь же редок, надеюсь). И все же программисты иногда используют номера для дифференциации таких методов, как OutputUser, OutputUser1 и OutputUser2. Номера в конце каждого из этих имен ничего не говорят о различиях представляемых методами абстракций, поэтому такие имена нельзя признать удачными.</p>
<p><b>Не ограничивайте длину имен методов искусственными правилами</b> Исследования показывают, что оптимальная длина имени переменной равняется в среднем 9–15 символам. Как правило, методы сложнее переменных, поэтому и адекватные имена методов обычно длиннее. В то же время к именам методов часто присоединяются имена объектов, что по сути предоставляет методам часть имени «бесплатно». Главной задачей имени метода следует считать как можно более ясное и понятное описание сути метода, поэтому имя может иметь любую длину, удовлетворяющую этой цели.</p>
<p>Для именования функции используйте описание возвращаемого значения Функция возвращает значение, и это следует должным образом отразить в ее имени. Так, имена cos(), customerId.Next(), printer.IsReady() и pen. CurrentColor() ясно указывают, что возвращают функции, и потому являются удачными.</p>
<p>Для именования процедуры используйте выразительный глагол, дополняя его объектом Процедура с функциональной связностью обычно выполняет операцию над объектом. Имя должно отражать выполняемое процедурой действие и объект, над которым оно выполняется, что приводит нас к формату «глагол + объект». Примеры удачных имен процедур — PrintDocument(), CalcMonthlyRevenues(), CheckOrderInfo() и RepaginateDocument().</p>
<p>В случае объектно-ориентированных языков имя объекта в имя процедуры включать не нужно, потому что объекты и так входят в состав вызовов, принимающих вид document.Print(), orderInfo.Check() и monthlyRevenues.Calc(). Имена вида document.PrintDocument() страдают от избыточности и могут стать в производных классах неверными. Если Check — класс, производный от класса Document, суть вызова check.Print() кажется очевидной: печать чека. В то же время вызов check.PrintDocument() похож на печать записи чековой книжки или ежемесячной выписки со счета, но никак не чека.</p>
<p><b>Дисциплинированно используйте антонимы</b> Применение конвенций именования, подразумевающих использование антонимов, поддерживает согласованность имен, что облегчает чтение кода. Антонимы вроде first/last понятны всем. Пары вроде FileOpen() и _lclose() несимметричны и вызывают замешательство. Вот некоторые антонимы, популярные в программировании:</p>
<table>
	<tr><td>add/remove</td><td>increment/decrement</td><td>open/close</td></tr>
	<tr><td>begin/end</td><td>insert/delete</td><td>show/hide</td></tr>
	<tr><td>create/destroy</td><td>lock/unlock</td><td>source/target</td></tr>
	<tr><td>first/last</td><td>min/max</td><td>start/stop</td></tr>
	<tr><td>get/put</td><td>next/previous</td><td>up/down</td></tr>
	<tr><td>get/set</td><td>old/new</td><td></td></tr>
</table>
<p><b>Определяйте конвенции именования часто используемых операций</b> При работе над некоторыми системами важно различать разные виды операций. Самым легким и надежным способом определения этих различий часто оказывается конвенция именования.</p>
<p>В одном из моих проектов каждый объект имел уникальный идентификатор. Мы не потрудились выработать конвенцию именования методов, возвращающих идентификатор объекта, и в итоге получили такие имена, как:</p>
<p class="preformatted">employee.id.Get()
dependent.GetId()
supervisor()
candidate.id()</p>
<p>Класс Employee предоставлял доступ к объекту id, который в свою очередь включал метод Get(). Класс Dependent предоставлял для этой цели метод GetId(). Разработчик класса Supervisor сделал id значением, возвращаемым по умолчанию. Класс Candidate предоставлял доступ к объекту id, который по умолчанию возвращал значение идентификатора. К середине проекта никто из нас уже не мог вспомнить, какой из методов предполагалось использовать для того или иного объекта, но мы уже написали слишком много кода, чтобы возвращаться назад и все согласовывать. Поэтому каждому члену группы пришлось тратить лишние усилия на запоминание несогласованных подробностей синтаксиса получения id из каждого класса. Конвенция именования, определяющая получение id, сделала бы такую неприятность невозможной.</p>
	</body>
</html>