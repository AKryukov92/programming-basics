<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8"/>
		<link href="styles.css" rel="stylesheet"></link>
	</head>
	<body>
	Цитата из книги "Совершенный код" с комментариями. Автор: С.Макконнел
	<p>Купить всю книгу можно на следующих сайтах:
	<ul>
		<li>ozon.ru <a href="http://www.ozon.ru/context/detail/id/138437220/" target="_blank">(открыть в новой вкладке)</a></li>
		<li>market.yandex.ru <a href="https://market.yandex.ru/product--makkonnell-s-sovershennyi-kod-master-klass/1545077" target="_blank">(открыть в новой вкладке)</a></li>
	</ul>
	</p>
	<h3>Часть II. Вступление к главе 7 "Высококачественные методы"</h3>
<p>В главе 6 мы подробно рассмотрели создание классов. В этой главе мы обратим внимание на методы и характеристики, отличающие хорошие методы от плохих. Если вам хотелось бы сначала разобраться в вопросах, влияющих на проектирование методов, прочитайте главу 5 и потом вернитесь к этой главе. Некоторые важные атрибуты высококачественных методов обсуждаются также в главе 8. Если вас больше интересуют этапы создания методов и классов, см. главу 9.</p>
<p>Прежде чем перейти к деталям, определим два базовых термина. Что такое «метод»? Метод — это отдельная функция или процедура, выполняющая одну задачу. В различных языках методы могут называться по-разному, но их суть от этого не меняется. Иногда макросы C и C++ также полезно рассматривать как методы. Многие советы по созданию высококачественных методов относятся и к макросам.</p>
<p>Что такое высококачественный метод? На этот вопрос ответить сложнее. Возможно, лучше всего просто показать, что не является высококачественным методом. Вот пример низкокачественного метода:</p>
<p>Пример низкокачественного метода</p>
<p class="preformatted">void HandleStuff( CORP_DATA & inputRec, int crntQtr, EMP_DATA empRec,
 double & estimRevenue, double ytdRevenue, int screenX, int screenY,
 COLOR_TYPE & newColor, COLOR_TYPE & prevColor, StatusType & status,
 int expenseType )
{
int i;
for ( i = 0; i &lt; 100; i++ ) {
   inputRec.revenue[i] = 0;
   inputRec.expense[i] = corpExpense[ crntQtr ][ i ];
   }
UpdateCorpDatabase( empRec );
estimRevenue = ytdRevenue * 4.0 / (double) crntQtr;
newColor = prevColor;
status = SUCCESS;
if ( expenseType == 1 ) {
     for ( i = 0; i &lt; 12; i++ )
           profit[i] = revenue[i] - expense.type1[i];
     }
else if ( expenseType == 2 ) {
          profit[i] = revenue[i] - expense.type2[i];
          }
else if ( expenseType == 3 )
          profit[i] = revenue[i] - expense.type3[i];
          }
</p>
<p>Что тут не так? Подскажу: вы должны найти минимум 10 недостатков. Составив свой список, сравните его с моим.</p>
<ul>
	<li>Неудачное имя: HandleStuff() ничего не говорит о роли метода.</li>
	<li>Метод недокументирован (вопрос документирования не ограничивается отдельными методами и обсуждается в главе 32).</li>
	<li>Метод плохо форматирован. Физическая организация кода почти не дает представления о его логической организации. Стратегии форматирования используются непоследовательно: сравните стили операторов if с условиями expenseType == 2 и expenseType == 3 (о форматировании см. главу 31).</li>
	<li>Входная переменная inputRec внутри метода изменяется. Если это входная переменная, изменять ее нежелательно (в случае C++ ее следовало бы объявить как const). Если изменение значения предусмотрено, переменную не стоило называть inputRec</li>
	<li>Метод читает и изменяет глобальные переменные: читает corpExpense и изменяет profit. Взаимодействие этого метода с другими следовало бы сделать более непосредственным, без использования глобальных переменных.</li>
	<li>Цель метода размыта. Он инициализирует ряд переменных, записывает данные в БД, выполняет вычисления — все эти действия не кажутся связанными между собой. Метод должен иметь одну четко определенную цель.</li>
	<li>Метод не защищен от получения плохих данных. Если переменная crntQtr равна 0, выражение ytdRevenue * 4.0 / (double) crntQtr вызывает ошибку деления на 0</li>
	<li>Метод использует несколько «магических» чисел: 100, 4.0, 12, 2 и 3 (о магических числах см. раздел 12.1).</li>
	<li>Параметры screenX и screenY внутри метода не используются.</li>
	<li>Параметр prevColor передается в метод неверно: он передается по ссылке (&), но значение ему внутри метода не присваивается.</li>
	<li>Метод принимает слишком много параметров. Как правило, чтобы параметры можно было охватить умом, их должно быть не более 7 — этот метод принимает 11. Параметры представлены таким неудобочитаемым образом, что большинство разработчиков даже не попытаются внимательно изучить их или хотя бы подсчитать.</li>
	<li>Параметры метода плохо упорядочены и не документированы (об упорядочении параметров см. эту главу, о документировании — главу 32).</li>
</ul>
<p>Если не считать сами компьютеры, методы — величайшее изобретение в области компьютерных наук. Методы облегчают чтение и понимание программ в большей степени, чем любая другая возможность любого языка программирования, и оскорблять столь заслуженных в мире программирования деятелей таким кодом, что был приведен выше, — настоящее преступление.</p>
<p>Кроме того, методы — самый эффективный способ уменьшения объема и повышения быстродействия программ. Представьте, насколько объемнее были бы ваши программы, если б вместо каждого вызова метода нужно было вставить соответствующий код. Представьте, насколько сложнее было бы оптимизировать код, если бы он был распространен по всей программе, а не локализован в одном методе. Программирование, каким мы его знаем сегодня, оказалось бы без методов невозможным.</p>
<p>«Хорошо, — скажете вы. — Я уже знаю, что методы очень полезны и постоянно их использую. Чего ж вы от меня хотите?»</p>
<p>Я хочу, чтобы вы поняли, что есть много веских причин, а также правильных и неправильных способов создания методов. Будучи студентом факультета информатики, я думал, что главная причина создания методов — предотвращение дублирования кода. Во вводном учебнике, по которому я учился, полезность методов обосновывалась тем, что предотвращение дублирования кода делает программу более простой в разработке, отладке, документировании и сопровождении. Точка. Если не считать синтаксические детали использования параметров и локальных переменных, на этом обсуждение методов в той книге заканчивалось. Такое объяснение теории и практики использования методов нельзя считать ни удачным, ни полным. В следующих разделах я постараюсь это исправить.</p>
	</body>
</html>