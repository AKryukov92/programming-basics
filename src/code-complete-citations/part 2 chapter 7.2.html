<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8"/>
		<link href="styles.css" rel="stylesheet"></link>
	</head>
	<body>
	Цитата из книги "Совершенный код" с комментариями. Автор: С.Макконнел
	<p>Купить всю книгу можно на следующих сайтах:
	<ul>
		<li>ozon.ru <a href="http://www.ozon.ru/context/detail/id/138437220/" target="_blank">(открыть в новой вкладке)</a></li>
		<li>market.yandex.ru <a href="https://market.yandex.ru/product--makkonnell-s-sovershennyi-kod-master-klass/1545077" target="_blank">(открыть в новой вкладке)</a></li>
	</ul>
	</p>
	<h3>Часть II. Глава 7.2 "Проектирование на уровне методов"</h3>
<p>Идею связности впервые представили Уэйн Стивенс, Гленфорд Майерс и Ларри Константайн (Stevens, Myers, and Constantine, 1974). На уровне проектирования классов ее практически вытеснили более современные концепции, такие как абстракция и инкапсуляция, однако на уровне проектирования отдельных методов эвристический принцип связности по-прежнему полезен.</p>
<p>В случае методов связность характеризует соответствие выполняемых в методе операций единой цели. Некоторые программисты предпочитают использовать термин «сила» (strength): насколько сильно связаны операции в методе? Например, метод Cosine() (косинус) имеет одну четко определенную цель и потому обладает прекрасной связностью. Метод CosineAndTan() (косинус и тангенс) имеет меньшую связность, потому что он выполняет сразу две функции. Наша цель в том, чтобы каждый метод эффективно решал одну задачу и больше ничего не делал.</p>
<p>Вознаграждением будет более высокая надежность кода. В одном исследовании 450 методов было обнаружено, что дефекты отсутствовали в 50% методов, обладающих высокой связностью, и только в 18% методов с низкой связностью (Card, Church, and Agresti, 1986). Другое исследование 450 методов (это просто совпадение, хотя и весьма необычное) показало, что в сравнении с методами, имеющими самое низкое отношение «сопряжение/связность» (coupling-to-cohesion), методы с максимальным отношением «сопряжение/связность» содержали в 7 раз больше ошибок, а исправление этих методов было в 20 раз более дорогим (Selby and Basili, 1991).</p>
<p>Обсуждение связности обычно касается нескольких ее уровней. Понять эти концепции важнее, чем запомнить специфические термины. Используйте концепции как средства, помогающие сделать методы максимально связными.</p>
<ul><li><b>Функциональная связность</b> — самый сильный и лучший вид связности; она имеет место, когда метод выполняет одну и только одну операцию. Примерами методов, обладающих высокой связностью, являются методы sin() (синус), GetCustomerName() (получить фамилию заказчика), EraseFile() (удалить файл), CalculateLoanPayment() (вычислить плату за кредит) и AgeFromBirthdate() (определить возраст по дате рождения). Конечно, такая оценка связности предполагает, что эти методы соответствуют своим именам — иначе они имеют неудачные имена, а об их связности нельзя сказать ничего определенного.</li></ul>
<p>Ниже описаны другие виды связности, которые обычно считаются менее эффективными.</p>
<ul>
	<li><p><b>Последовательная связность (sequential cohesion)</b> наблюдается в том случае, когда метод содержит операции, которые обязательно выполняются в определенном порядке, используют данные предыдущих этапов и не формируют в целом единую функцию.</p>
	<p>Примером метода с последовательной связностью является метод, вычисляющий по дате рождения возраст сотрудника и срок до его ухода на пенсию. Если метод вычисляет возраст и затем использует этот результат для нахождения срока до ухода сотрудника на пенсию, он имеет последовательную связность.</p>
	<p>Если метод находит возраст сотрудника, после чего в абсолютно другом вычислении определяет срок до ухода на пенсию, применяя те же данные о дате рождения, он имеет только коммуникационную связность.</p>
	<p>Как сделать такой метод функционально связным? Создать два отдельных метода: метод, вычисляющий по дате рождения возраст сотрудника, и метод, определяющий по дате рождения срок до ухода сотрудника на пенсию. Второй метод мог бы вызывать метод нахождения возраста. Оба этих метода имели бы функциональную связность. Другие методы могли бы вызывать любой из них или оба.</p></li>
	
	<li><p><b>Коммуникационная связность (communicational cohesion)</b> имеет место, когда выполняемые в методе операции используют одни и те же данные и не связаны между собой иным образом. Если метод печатает отчет, после чего заново инициализирует переданные в него данные, он имеет коммуникационную связность: две операции объединяет только то, что они обращаются к одним и тем же данным.</p>
	<p>Чтобы повысить связность этого метода, выполняйте повторную инициализацию данных около места их создания, которое не должно находиться в методе печати отчета. Разделите операции на два метода: первый будет печатать отчет, а второй — выполнять повторную инициализацию данных неподалеку от кода, создающего или изменяющего данные. Вызовите оба этих метода вместо первоначального метода, имевшего коммуникационную связность.</p></li>
	
	<li><p><b>Временная связность (temporal cohesion)</b> наблюдается, когда операции объединяются в метод на том основании, что все они выполняются в один интервал времени. Типичные примеры — методы Startup() (запуск программы) CompleteNewEmployee() (прием нового сотрудника на работу) и Shutdown() (завершение программы). Временную связность порой считают неприемлемой, поскольку иногда она связана с плохими методиками программирования, такими как включение слишком разнообразного кода в метод Startup().</p>
	<p>Для устранения этой проблемы рассматривайте методы с временной связностью как способы организации других событий. Так, метод Startup() мог бы читать конфигурационный файл, инициализировать вспомогательный файл, настраивать менеджер памяти и выводить первоначальное окно программы. Чтобы сделать метод с временной связностью максимально эффективным, не выполняйте в нем конкретных операций непосредственно, а вызывайте для их выполнения другие методы. Тогда всем будет ясно, что суть метода — согласование действий, а не их выполнение.</p>
	<p>Этот пример поднимает вопрос выбора имени, описывающего такой метод с адекватным уровнем абстракции. Вы могли бы назвать метод ReadConfigFileInitScratchFileEtc() (прочитать конфигурационный файл, инициализировать вспомогательный файл и т. д.), но из этого следовало бы, что он имеет только случайную связность. Если же вы назовете метод Startup(), будет очевидно, что он имеет одну цель и поэтому обладает функциональной связностью.</p></li>
</ul>
<p><b>Остальные виды связности обычно неприемлемы.</b> Они приводят к созданию плохо организованного кода, который трудно отлаживать и изменять. Метод с плохой связностью лучше переписать, чем тратить время и средства на поиск проблем. Однако знание того, чего следует избегать, может пригодиться, поэтому ниже я привел описания плохих видов связности.</p>
<ul>
	<li><p><b>Процедурная связность (procedural cohesion)</b> имеет место, когда операции в методе выполняются в определенном порядке. В качестве примера можно привести метод, получающий фамилию сотрудника, затем его адрес, а после этого номер телефона. Порядок этих операций важен только потому, что он соответствует порядку, в котором пользователя просят ввести данные. Остальные данные о сотруднике получает другой метод. В данном случае операции выполняются в определенном порядке и не объединены больше ничем, поэтому метод имеет процедурную связность.</p>
	<p>Для достижения лучшей связности поместите разные операции в отдельные методы. Сделайте так, чтобы вызывающий метод решал одну задачу, причем полностью: пусть он соответствует имени GetEmployee() (получить данные о сотруднике), а не GetFirstPartOfEmployeeData() (получить первую часть данных о сотруднике). Вероятно, при этом придется изменить и методы, получающие остальные данные. Довольно часто достижение функциональной связности требует изменения двух или более первоначальных методов.</p></li>
	
	<li><p><b>Логическая связность (logical cohesion)</b> имеет место, когда метод включает несколько операций, а выбор выполняемой операции осуществляется на основе передаваемого в метод управляющего флага. Этот вид связности называется логическим потому, что операции метода объединены только управляющей «логикой» метода: крупным оператором if или рядом блоков case. Какой-нибудь другой по-настоящему «логической» связи между операциями нет. Поскольку определяющим атрибутом логической связности является отсутствие отношений между операциями, возможно, лучше было бы назвать ее «нелогичной связностью».</p>
	<p>В качестве примера такого метода можно привести метод InputAll(), принимающий в зависимости от полученного флага фамилии клиентов, данные карт учета времени сотрудников или инвентаризационные данные. Другие примеры — методы ComputeAll(), EditAll(), PrintAll() и SaveAll(). Главная проблема с ними в том, что передавать флаг для управления работой метода нецелесообразно. Вместо метода, выполняющего одну из трех операций в зависимости от полученного флага, лучше создать три метода, выполняющих по одной операции. Если операции используют некоторый одинаковый код или общие данные, код следует переместить в метод более низкого уровня, а методы упаковать в класс.</p>
	<p>Однако логически связный метод вполне приемлем, если его код состоит исключительно из ряда операторов if или case и вызовов других методов. Если единственная роль метода — координация выполнения команд и сам он не выполняет действий, это обычно удачное проектное решение. Такие методы еще называют «обработчиками событий». Обработчики часто используются в интерактивных средах, таких как Apple Macintosh, Microsoft Windows и других средах с GUI</p></li>

	<li><p>При <b>случайной связности (coincidental cohesion)</b> каких-либо ясных отношений между выполняемыми в методе операциями нет. Этот вариант можно еще называть «отсутствием связности» или «хаотичной связностью». Низкокачественный метод C++, приведенный в начале этой главы, имеет случайную связность. Случайную связность трудно преобразовать в более приемлемый вид связности — как правило, методы со случайной связностью нужно проектировать и реализовать заново.</p></li>
</ul>
<p>Никакой из этих терминов не является магическим или священным. <b>Изучайте идеи, а не терминологию.</b> Стремитесь создавать методы с функциональной связностью — это возможно почти всегда.</p>
	</body>
</html>