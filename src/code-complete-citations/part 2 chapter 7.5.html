<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8"/>
		<link href="styles.css" rel="stylesheet"></link>
	</head>
	<body>
	Цитата из книги "Совершенный код" с комментариями. Автор: С.Макконнел
	<p>Купить всю книгу можно на следующих сайтах:
	<ul>
		<li>ozon.ru <a href="http://www.ozon.ru/context/detail/id/138437220/" target="_blank">(открыть в новой вкладке)</a></li>
		<li>market.yandex.ru <a href="https://market.yandex.ru/product--makkonnell-s-sovershennyi-kod-master-klass/1545077" target="_blank">(открыть в новой вкладке)</a></li>
	</ul>
	</p>
	<h3>Часть II. Фрагменты из главы 7.5 "Советы по использованию параметров методов"</h3>
<p class="comment">Из главы взяты только некоторые части, которые будет полезно узнать в данный момент. Другие советы будут неоправданно отвлекать ваше внимание. Обязательно прочитайте главу целиком, но как-нибудь потом.</p>
<p>Интерфейсы между методами — один из основных источников ошибок. В одном часто цитируемом исследовании, проведенном Базили и Перриконе (Basili and Perricone, 1984), было обнаружено, что 39% всех ошибок были ошибками внутренних интерфейсов — ошибками коммуникации между методами. Вот несколько советов по предотвращению подобных проблем.</p>
<p><b>Если несколько методов используют похожие параметры, передавайте их в согласованном порядке</b> Порядок параметров может как облегчить, так и затруднить их запоминание. Например, в C прототипы методов fprintf() и printf() различаются только тем, что fprintf() принимает файл в качестве дополнительного первого аргумента. Похожее отношение наблюдается и между методами fputs() и puts(), но в fputs() файл передается последним. Это досадное различие только затрудняет запоминание параметров названных методов. С другой стороны, методы strncpy() и memcpy() в том же C принимают аргументы в одинаковом порядке: строка-приемник, строка-источник и максимальное число копируемых байт. Такое сходство помогает запомнить параметры обоих методов.</p>
<p><b>Используйте все параметры</b> Если вы передаете параметр в метод, используйте его, в противном случае удалите параметр из интерфейса метода. Наличие неиспользуемых параметров соответствует более высокому уровню ошибок. Исследования показали, что ошибки отсутствовали в 46% методов, не включавших неиспользуемых переменных, и только в 17–29% методов, содержавших более одной неиспользуемой переменной (Card, Church, and Agresti, 1986).</p>
<p>Это правило допускает одно исключение. При условной компиляции кода из компиляции могут быть исключены части метода, использующие некоторый параметр. Опасайтесь этого подхода, но, если вы убеждены, что все правильно, он вполне допустим. В общем, если у вас есть серьезная причина не использовать параметр, оставьте его в списке. Если таковой нет, очистите интерфейс метода от примесей.</p>
<p><b>Не используйте параметры метода в качестве рабочих переменных</b> Использовать передаваемые в метод параметры как рабочие переменные опасно. Создайте для этой цели локальные переменные. Так, в следующем фрагменте Java-кода переменная inputVal некорректно служит для хранения промежуточных результатов вычислений:</p>
<p>Пример некорректного использования входного параметра (Java)</p>
<p class="preformatted">int Sample( int inputVal ) {
    inputVal = inputVal * CurrentMultiplier( inputVal );
    inputVal = inputVal + CurrentAdder( inputVal );
    ...</p>
<p>Переменная inputVal уже не содержит входного значения.</p>
<p class="preformatted">    return inputVal;
}</p>
<p>В этом фрагменте переменная inputVal вводит в заблуждение, потому что при завершении метода она больше не содержит входного значения; она содержит результат вычисления, частично основанного на входном значении, и поэтому ее имя неудачно. Если позднее вам придется задействовать первоначальное входное значение в другом месте метода, вы, вероятно, задействуйте переменную inputVal, предполагая, что она содержит первоначальное значение, но это предположение будет ошибочным.</p>
<p>Можно ли решить эту проблему путем переименования inputVal? Наверное, нет. Переменной можно было бы присвоить имя вроде workingVal, но такое решение было бы неполным, так как это имя не говорит о том, что первоначальное значение переменной передается в метод извне. Вы могли бы присвоить ей нелепое имя inputValThatBecomesWorkingVal (входное значение, которое становится рабочим значением) или сдаться и просто назвать ее x или val, но все эти подходы неудачны.</p>
<p>Лучше избегать настоящих и будущих проблем, используя рабочие переменные явно, например:</p>
<p>Пример корректного использования входного параметра (Java)</p>
<p class="preformatted">int Sample( int inputVal ) {
    int workingVal = inputVal;
    workingVal = workingVal * CurrentMultiplier( workingVal );
    workingVal = workingVal + CurrentAdder( workingVal );
    ...</p>
<p>Если первоначальное значение inputVal понадобится здесь или где-то еще, оно все еще доступно.</p>
<p class="preformatted">    ...
    return workingVal;
}</p>
<p>Создание новой переменной workingVal поясняет роль inputVal и исключает возможность ошибочного использования inputVal в неподходящий момент. (Не рассматривайте это рассуждение как оправдание присвоения переменным имен inputVal или workingVal. Имена inputVal и workingVal просто ужасны и служат в данном примере только для пояснения ролей переменных.)</p>
<p>Присвоение входного значения рабочей переменной подчеркивает тот факт, что значение поступает в метод извне. Кроме того, это исключает возможность случайного изменения параметров. В C++ ответственность за это можно возложить на компилятор при помощи ключевого слова const. Отметив параметр как const, вы не сможете изменить его значение внутри метода.</p>
<p><b>Документируйте выраженные в интерфейсе предположения о параметрах</b> Если вы предполагаете, что передаваемые в метод данные должны иметь определенные характеристики, сразу же документируйте эти предположения. Документирование предположений и в самом методе, и в местах его вызова нельзя назвать пустой тратой времени. Пишите комментарии, не дожидаясь завершения работы над методом: к тому времени вы многое забудете. Еще лучше применить утверждения (assertions), позволяющие встроить предположения в код.</p>
<p>Какие типы предположений о параметрах следует документировать? Вот какие:</p>
<ul>
	<li>вид параметров: являются ли они исключительно входными, изменяемыми или исключительно выходными;</li>
	<li>единицы измерения (дюймы, футы, метры и т. д.);</li>
	<li>смысл кодов статуса и ошибок, если для их представления не используются перечисления;</li>
	<li>диапазоны допустимых значений;</li>
	<li>специфические значения, которые никогда не должны передаваться в метод.</li>
</ul>
<p><b>Ограничивайте число параметров метода примерно семью</b> 7 — магическое число. Психологические исследования показали, что люди, как правило, не могут следить более чем за семью элементами информации сразу (Miller, 1956). Это открытие используется в огромном числе дисциплин, поэтому резонно предположить, что большинство людей не может удерживать в уме более семи параметров метода одновременно.</p>
<p>На практике возможность ограничения числа параметров зависит от того, как в выбранном вами языке реализована поддержка сложных типов данных. Программируя на современном языке, поддерживающем структурированные данные, вы можете передать в метод составной тип данных, содержащий 13 полей, и рассматривать его как один «элемент» данных. При использовании более примитивного языка вам, возможно, придется передать все 13 полей по отдельности.</p>
<p>Если вам постоянно приходится передавать в методы слишком большое число аргументов, ваши методы имеют слишком сильное сопряжение. Проектируйте методы или группы методов так, чтобы сопряжение было слабым. Если вы передаете одни и те же данные во многие разные методы, сгруппируйте эти методы и данные в класс.</p>
<p><b>Передавайте в метод те переменные или объекты, которые нужны ему для поддержания абстракции интерфейса</b> Есть два конкурирующих подхода к передаче членов объекта в методы. Допустим, у вас есть объект, предоставляющий доступ к данным посредством 10 методов доступа, но вызываемому методу нужны лишь три элемента данных объекта.</p>
<p>Сторонники первого подхода утверждают, что в метод следует передать только три нужных ему элемента. Они считают, что это позволяет поддерживать минимальное сопряжение между методами, способствует пониманию методов, облегчает их повторное использование и т. д. Они говорят, что передача всего объекта в метод нарушает принцип инкапсуляции, позволяя вызванному методу использовать все 10 методов доступа.</p>
<p>Сторонники второго подхода утверждают, что следует передать весь объект. Они говорят, что если вызываемый метод получит доступ к дополнительным членам объекта, это позволит сохранить стабильность интерфейса метода. Им кажется, что именно передача трех конкретных элементов нарушает инкапсуляцию, потому что это указывает на конкретные элементы данных, используемые методом.</p>
<p>Я думаю, что оба этих правила слишком упрощены и не учитывают самого важного: какую абстракцию формирует интерфейс метода? Если абстракция подразумевает, что метод ожидает три конкретных элемента данных, которые по чистой случайности принадлежат одному объекту, передайте три элемента по отдельности. Если же абстракция состоит в том, что элементы данных всегда принадлежат конкретному объекту, над которым метод должен выполнять ту или иную операцию, тогда, раскрывая три этих специфических элемента, вы на самом деле нарушаете абстракцию.</p>
<p>Если при передаче всего объекта вы создаете объект, заполняете его тремя элементами, нужными методу, а после вызова извлекаете эти элементы из объекта, значит, вам следует передать в метод только три конкретных элемента, а не весь объект. (Обычно наличие кода, «подготавливающего» данные перед вызовом метода или «разбирающего» объект после вызова, — признак неудачного проектирования метода.)</p>
<p>Если же вам часто приходится изменять список параметров метода, при этом каждый раз параметры относятся к одному и тому же объекту, в метод следует передавать весь объект, а не конкретные элементы.</p>
	</body>
</html>